include "std"

struct vector<T> {
	m_data: ptr,
	m_size: int,
	m_cap : int
}

struct VectorIterator<T> {
	_ptr: ptr
}

impl VectorIterator<T> [new] {
	proc new<T>(ptr __p) -> VectorIterator<T> {
		return VectorIterator<T>(__p);
	}
	proc m_inc(VectorIterator<T> self, int __count) {
		self._ptr += __count * 4;
	}
	proc m_equal(VectorIterator<T> lhs, VectorIterator<T> rhs) -> int {
		return lhs._ptr == rhs._ptr;
	}
	proc m_not_equal(VectorIterator<T> lhs, VectorIterator<T> rhs) -> int {
		return lhs._ptr != rhs._ptr;
	}
	proc m_assign_deref(VectorIterator<T> self) -> T {
		return cast(T, self._ptr);
	}
	proc m_deref(VectorIterator<T> self) -> T {
		return cast(T, rd32(self._ptr));
	}
	proc deref_to(VectorIterator<T> self) -> T {
		return self~m_deref();
	}
}

impl vector<T> [new] {
	proc new<T>() -> vector<T> {
		return vector<T>(memalloc(sizeof(T)), 0, sizeof(T) / 4);
	}
	proc begin(vector<T> self) -> VectorIterator<T> {
		return VectorIterator::new<T>(self.m_data);
	}
	proc end(vector<T> self) -> VectorIterator<T> {
		return VectorIterator::new<T>(self.m_data + ((self.m_size) * 4));
	}
	proc extend(vector<T> self) {
		let tmp = memalloc((self.m_cap * 4) * 2);
		memcpy(tmp, self.m_data, self.m_size * 4);
		memfree(self.m_data);
		self.m_cap = self.m_cap * 2;
		self.m_data = tmp;
	}
	proc reserve(vector<T> self, int ncap) {
		if((ncap < self.m_cap) || (ncap == self.m_cap)) return;
		while(self.m_cap < ncap) {
			self~extend();
		}
	}
	proc setsize(vector<T> self, int newsz) {
		self.m_size = newsz;
	}
	proc reserve_setsize(vector<T> self, int ncap) {
		self~reserve(ncap);
		self~setsize(ncap);
	}
	proc set(vector<T> self, int index, T value) {
		store32(self.m_data + (index * 4), value);
	}
	proc push(vector<T> self, T value) {
		if(self.m_size == (self.m_cap)) {
			self~extend();
		}
		self~set(self.m_size, value);
		self.m_size += 1;
	}
	proc empty(vector<T> self) -> int {
		return self.m_size == 0;
	}
	proc insert(vector<T> self, int index, T value) {
		if(self.m_size < index) {
			raise std::exception("index out of bounds");
		}
		if(self.m_size == 0) {
			self~push(value);
			return;
		}
		if(self.m_size == self.m_cap) {
			self~extend();
		}
		memmove(self.m_data + ((index + 1) * 4), 
		        self.m_data + (index * 4), 
		        (self.m_size * 4) - (index * 4));
		
		store32(self.m_data + (index * 4), value);
		self.m_size += 1;
	}
	proc get(vector<T> self, int index) -> T {
		return cast(T, rd32(self.m_data + (index * 4)));
	}
	proc at(vector<T> self, int index) -> T {
		if(self.m_size < (index + 1)) raise std::exception("index > m_size");
		return self~get(index);
	}
	proc pop(vector<T> self) -> T {
		self.m_size -= 1;
		return self~get(self.m_size);
	}
	proc m_assign(vector<T>& self, vector<T>&& other) -> void {
		std::__container_move(other, cast(vector<T>&&, self));
	}
	proc m_fprint(vector<T> self, int fd) {
		let __sz: int = self.m_size;
		if(__sz == 0) {
			std::fprint(fd, "vector[]\n");
			return;
		}
		let i = 0;
		std::fprint(fd, "vector[");
		while(i < __sz) {
			std::fprint(fd, self~get(i));
			if(i != (__sz - 1)) {
				std::fprint(fd, ", ");
			}
			i += 1;
		}
		std::fprint(fd, "]");
	}
	proc destroy(vector<T> self) {
		#if(is_object_t(ct_type(T))) {
			let i: int = 0;
			try {
				while(i < self.m_size) {
					delete self~get(i);
					i += 1;
				}
			} catch (err: exception) {
				raise std::exception("vector::destroy() -> T::destroy() cause exception");
			}
		}
		memfree(self.m_data);
	}
}