include "std"


const MAP_INITIAL_CAP = 16;
const MAP_LOAD_FACTOR_PERCENT = 75; // 75%

struct MapEntry<K, V> {
    key: K,
    value: V
}

impl MapEntry<K, V> [new] {
    proc new<K, V>(K key, V val) -> MapEntry<K, V> {
        return MapEntry<K, V>(key, val);
    }
    proc m_equal(MapEntry<K, V> self, MapEntry<K, V> other) -> int {
        return (std::equal(self.key, other.key)) && (std::equal(self.value, other.value));
    }
}

struct MapIterator<K, V> {
    _map:        ptr,
    _bucket_idx: int,
    _node:       ptr
}

impl MapIterator<K, V> [new] {
    proc new<K, V>(ptr m, int idx, ptr node) -> MapIterator<K, V> {
        return MapIterator<K, V>(m, idx, node);
    }

    proc m_equal(MapIterator<K, V> lhs, MapIterator<K, V> rhs) -> int {
        return (lhs._node == rhs._node) && (lhs._bucket_idx == rhs._bucket_idx);
    }

    proc m_not_equal(MapIterator<K, V> lhs, MapIterator<K, V> rhs) -> int {
        return (lhs._node != rhs._node) || (lhs._bucket_idx != rhs._bucket_idx);
    }

    proc m_deref(MapIterator<K, V> self) -> MapEntry<K, V> {
        if (self._node == null()) {
            raise std::exception("MapIterator dereference out of bounds");
        }
        let node = cast(MapNode<K, V>, self._node); 
        return MapEntry<K, V>(node.key, node.value);
    }

    proc m_assign(MapIterator<K, V>& self, MapIterator<K, V> other) {
        store32(cast(ptr, self), other);
    }

    proc m_inc(MapIterator<K, V> self, int __cnt) {
        if (self._node != null()) {
            let node = cast(MapNode<K, V>, self._node);
            self._node = node.next;
        }

        if (self._node == null()) {
            let m = cast(map<K, V>, self._map);
            
            self._bucket_idx += 1;
            while (self._bucket_idx < m.m_cap) {
                // Доступ к бакетам через m
                let bucket_addr = m.m_buckets + (self._bucket_idx * 4);
                let head = cast(ptr, rd32(bucket_addr));
                
                if (head != null()) {
                    self._node = head;
                    return;
                }
                self._bucket_idx += 1;
            }
        }
    }
}

struct MapNode<K, V> {
    key:   K,
    value: V,
    next:  ptr
}

struct map<K, V> {
    m_buckets: ptr,
    m_size:    int,
    m_cap:     int
}

impl map<K, V> [new] {

    proc new<K, V>() -> map<K, V> {
        let raw_map = memalloc(sizeof(map<K, V>));
        let mref    = cast(map<K, V>*, raw_map);

        mref.m_cap  = MAP_INITIAL_CAP;
        mref.m_size = 0;
        mref.m_buckets = memalloc(MAP_INITIAL_CAP * 4);

        let i = 0;
        while(i < MAP_INITIAL_CAP) {
            store32(mref.m_buckets + (i * 4), null());
            i += 1;
        }

        return cast(map<K, V>, raw_map);
    }


    proc _bucket_idx(map<K, V> self, K key) -> int {
        let h = std::hash(key);
        if(h < 0) { h = 0 - h; }
        return h % self.m_cap;
    }

    proc _rehash(map<K, V> self) {
        let old_cap     = self.m_cap;
        let old_buckets = self.m_buckets;

        let new_cap     = old_cap * 2;
        let new_buckets = memalloc(new_cap * 4);

        let i = 0;
        while(i < new_cap) {
            store32(new_buckets + (i * 4), null());
            i += 1;
        }

        self.m_buckets = new_buckets;
        self.m_cap     = new_cap;

        i = 0;
        while(i < old_cap) {
            let current = cast(ptr, rd32(old_buckets + (i * 4)));

            while(current != null()) {
                let node_ref = cast(MapNode<K, V>*, current);
                let next     = node_ref.next;

                let new_idx     = self._bucket_idx(node_ref.key);
                let bucket_addr = self.m_buckets + (new_idx * 4);

                let head = cast(ptr, rd32(bucket_addr));
                node_ref.next = head;
                store32(bucket_addr, current);

                current = next;
            }

            i += 1;
        }

        memfree(old_buckets);
    }

    proc put(map<K, V> self, K key, V value) {
        if ((self.m_size * 100) / self.m_cap > (MAP_LOAD_FACTOR_PERCENT - 1)) {
            self._rehash();
        }

        let idx         = self._bucket_idx(key);
        let bucket_addr = self.m_buckets + (idx * 4);
        let current     = cast(ptr, rd32(bucket_addr));

        while(current != null()) {
            let node_ref = cast(MapNode<K, V>*, current);

            if(std::equal(node_ref.key, key)) {
                #if(is_object_t(ct_type(V))) { delete node_ref.value; }
                node_ref.value = value;
                return;
            }

            current = node_ref.next;
        }

        let head = cast(ptr, rd32(bucket_addr));

        let new_node = MapNode<K, V>(key, value, head);

        store32(bucket_addr, new_node);
        self.m_size += 1;
    }

    proc get(map<K, V> self, K key) -> V {
        let idx         = self._bucket_idx(key);
        let bucket_addr = self.m_buckets + (idx * 4);
        let current     = cast(ptr, rd32(bucket_addr));

        while(current != null()) {
            let node_ref = cast(MapNode<K, V>*, current);
            if(std::equal(node_ref.key, key)) {
                return node_ref.value;
            }
            current = node_ref.next;
        }

        raise std::exception("Key not found in map");
    }

    proc has(map<K, V> self, K key) -> int {
        let idx         = self._bucket_idx(key);
        let bucket_addr = self.m_buckets + (idx * 4);
        let current     = cast(ptr, rd32(bucket_addr));

        while(current != null()) {
            let node_ref = cast(MapNode<K, V>*, current);
            if(std::equal(node_ref.key, key)) {
                return 1;
            }
            current = node_ref.next;
        }
        return 0;
    }

    proc remove(map<K, V> self, K key) {
        let idx         = self._bucket_idx(key);
        let bucket_addr = self.m_buckets + (idx * 4);
        let current     = cast(ptr, rd32(bucket_addr));
        let prev        = null();

        while(current != null()) {
            let node_ref = cast(MapNode<K, V>*, current);

            if(std::equal(node_ref.key, key)) {
                if(prev == null()) {
                    store32(bucket_addr, node_ref.next);
                } else {
                    let prev_ref = cast(MapNode<K, V>*, prev);
                    prev_ref.next = node_ref.next;
                }

                #if(is_object_t(ct_type(K))) { delete node_ref.key; }
                #if(is_object_t(ct_type(V))) { delete node_ref.value; }

                memfree(current);
                self.m_size -= 1;
                return;
            }

            prev    = current;
            current = node_ref.next;
        }
    }

    proc size(map<K, V> self) -> int {
        return self.m_size;
    }

    proc empty(map<K, V> self) -> int {
        return self.m_size == 0;
    }

    proc m_fprint(map<K, V> self, int fd) {
        std::fprint(fd, "{");

        let first = 1;
        let i = 0;

        while(i < self.m_cap) {
            let current = cast(ptr, rd32(self.m_buckets + (i * 4)));

            while(current != null()) {
                let node_ref = cast(MapNode<K, V>*, current);

                if(first == 0) {
                    std::fprint(fd, ", ");
                }
                first = 0;

                std::fprint(fd, node_ref.key);
                std::fprint(fd, ": ");

                std::fprint(fd, node_ref.value);

                current = node_ref.next;
            }

            i += 1;
        }

        std::fprint(fd, "}");
    }

    proc begin(map<K, V> self) -> MapIterator<K, V> {
        let i = 0;
        while (i < self.m_cap) {
            let head = cast(ptr, rd32(self.m_buckets + (i * 4)));
            if (head != null()) {
                return MapIterator<K, V>(cast(ptr, self), i, head);
            }
            i += 1;
        }
        return self.end();
    }

    proc end(map<K, V> self) -> MapIterator<K, V> {
        return MapIterator<K, V>(cast(ptr, self), self.m_cap, null());
    }

    proc destroy(map<K, V> self) {
        let i = 0;
        while(i < self.m_cap) {
            let current = cast(ptr, rd32(self.m_buckets + (i * 4)));

            while(current != null()) {
                let node_ref = cast(MapNode<K, V>*, current);
                let next     = node_ref.next;

                #if(is_object_t(ct_type(K))) { delete node_ref.key; }
                #if(is_object_t(ct_type(V))) { delete node_ref.value; }

                memfree(current);
                current = next;
            }

            i += 1;
        }

        memfree(self.m_buckets);
        self.m_buckets = null();
        self.m_size    = 0;
        self.m_cap     = 0;
    }
}