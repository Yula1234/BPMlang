include "std"

// ------------------------------------------------------------
// Простая хеш-таблица с цепочечной адресацией:
//   map<K, V>
//   - map::new<K, V>() -> map<K, V>
//   - self.put(key, value)
//   - self.get(key) -> V      (бросает std::exception, если нет ключа)
//   - self.has(key) -> int    (1 / 0)
//   - self.remove(key)
//   - self.size() -> int
//   - self.empty() -> int
//   - self.destroy()          (для delete self)
// ------------------------------------------------------------

const MAP_INITIAL_CAP = 16;
const MAP_LOAD_FACTOR_PERCENT = 75; // 75%

struct MapNode<K, V> {
    key:   K,
    value: V,
    next:  ptr
}

struct map<K, V> {
    m_buckets: ptr,
    m_size:    int,
    m_cap:     int
}

impl map<K, V> [new] {

    proc new<K, V>() -> map<K, V> {
        let raw_map = memalloc(sizeof(map<K, V>));
        let mref    = cast(map<K, V>*, raw_map);

        mref.m_cap  = MAP_INITIAL_CAP;
        mref.m_size = 0;
        mref.m_buckets = memalloc(MAP_INITIAL_CAP * 4);

        let i = 0;
        while(i < MAP_INITIAL_CAP) {
            store32(mref.m_buckets + (i * 4), null());
            i += 1;
        }

        return cast(map<K, V>, raw_map);
    }


    proc _bucket_idx(map<K, V> self, K key) -> int {
        let h = std::hash(key);
        if(h < 0) { h = 0 - h; }
        return h % self.m_cap;
    }

    proc _rehash(map<K, V> self) {
        let old_cap     = self.m_cap;
        let old_buckets = self.m_buckets;

        let new_cap     = old_cap * 2;
        let new_buckets = memalloc(new_cap * 4);

        let i = 0;
        while(i < new_cap) {
            store32(new_buckets + (i * 4), null());
            i += 1;
        }

        self.m_buckets = new_buckets;
        self.m_cap     = new_cap;

        i = 0;
        while(i < old_cap) {
            let current = cast(ptr, rd32(old_buckets + (i * 4)));

            while(current != null()) {
                let node_ref = cast(MapNode<K, V>*, current);
                let next     = node_ref.next;

                let new_idx     = self._bucket_idx(node_ref.key);
                let bucket_addr = self.m_buckets + (new_idx * 4);

                let head = cast(ptr, rd32(bucket_addr));
                node_ref.next = head;
                store32(bucket_addr, current);

                current = next;
            }

            i += 1;
        }

        memfree(old_buckets);
    }

    proc put(map<K, V> self, K key, V value) {
        if ((self.m_size * 100) / self.m_cap > (MAP_LOAD_FACTOR_PERCENT - 1)) {
            self._rehash();
        }

        let idx         = self._bucket_idx(key);
        let bucket_addr = self.m_buckets + (idx * 4);
        let current     = cast(ptr, rd32(bucket_addr));

        while(current != null()) {
            let node_ref = cast(MapNode<K, V>*, current);

            if(std::equal(node_ref.key, key)) {
                #if(is_object_t(ct_type(V))) { delete node_ref.value; }
                node_ref.value = value;
                return;
            }

            current = node_ref.next;
        }

        let head = cast(ptr, rd32(bucket_addr));

        let new_node = MapNode<K, V>(key, value, head);

        store32(bucket_addr, new_node);
        self.m_size += 1;
    }

    proc get(map<K, V> self, K key) -> V {
        let idx         = self._bucket_idx(key);
        let bucket_addr = self.m_buckets + (idx * 4);
        let current     = cast(ptr, rd32(bucket_addr));

        while(current != null()) {
            let node_ref = cast(MapNode<K, V>*, current);
            if(std::equal(node_ref.key, key)) {
                return node_ref.value;
            }
            current = node_ref.next;
        }

        raise std::exception("Key not found in map");
    }

    proc has(map<K, V> self, K key) -> int {
        let idx         = self._bucket_idx(key);
        let bucket_addr = self.m_buckets + (idx * 4);
        let current     = cast(ptr, rd32(bucket_addr));

        while(current != null()) {
            let node_ref = cast(MapNode<K, V>*, current);
            if(std::equal(node_ref.key, key)) {
                return 1;
            }
            current = node_ref.next;
        }
        return 0;
    }

    proc remove(map<K, V> self, K key) {
        let idx         = self._bucket_idx(key);
        let bucket_addr = self.m_buckets + (idx * 4);
        let current     = cast(ptr, rd32(bucket_addr));
        let prev        = null();

        while(current != null()) {
            let node_ref = cast(MapNode<K, V>*, current);

            if(std::equal(node_ref.key, key)) {
                if(prev == null()) {
                    store32(bucket_addr, node_ref.next);
                } else {
                    let prev_ref = cast(MapNode<K, V>*, prev);
                    prev_ref.next = node_ref.next;
                }

                #if(is_object_t(ct_type(K))) { delete node_ref.key; }
                #if(is_object_t(ct_type(V))) { delete node_ref.value; }

                memfree(current);
                self.m_size -= 1;
                return;
            }

            prev    = current;
            current = node_ref.next;
        }
    }

    proc size(map<K, V> self) -> int {
        return self.m_size;
    }

    proc empty(map<K, V> self) -> int {
        return self.m_size == 0;
    }

    proc m_fprint(map<K, V> self, int fd) {
        std::fprint(fd, "{");

        let first = 1;
        let i = 0;

        while(i < self.m_cap) {
            let current = cast(ptr, rd32(self.m_buckets + (i * 4)));

            while(current != null()) {
                let node_ref = cast(MapNode<K, V>*, current);

                if(first == 0) {
                    std::fprint(fd, ", ");
                }
                first = 0;

                // key
                std::fprint(fd, node_ref.key);
                std::fprint(fd, ": ");

                // value
                std::fprint(fd, node_ref.value);

                current = node_ref.next;
            }

            i += 1;
        }

        std::fprint(fd, "}");
    }

    proc destroy(map<K, V> self) {
        let i = 0;
        while(i < self.m_cap) {
            let current = cast(ptr, rd32(self.m_buckets + (i * 4)));

            while(current != null()) {
                let node_ref = cast(MapNode<K, V>*, current);
                let next     = node_ref.next;

                #if(is_object_t(ct_type(K))) { delete node_ref.key; }
                #if(is_object_t(ct_type(V))) { delete node_ref.value; }

                memfree(current);
                current = next;
            }

            i += 1;
        }

        memfree(self.m_buckets);
        self.m_buckets = null();
        self.m_size    = 0;
        self.m_cap     = 0;
    }
}