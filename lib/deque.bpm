include "std"

struct deque<T> {
	m_data: ptr,
	m_head: int, 
	m_size: int,
	m_cap:  int
}

struct DequeIterator<T> {
	_deq: ptr,
	_idx: int 
}

impl DequeIterator<T> [new] {
	proc new<T>(ptr __d, int __i) -> DequeIterator<T> {
		return DequeIterator<T>(__d, __i);
	}
	
	proc m_inc(DequeIterator<T> self, int __count) {
		self._idx += __count;
	}
	
	proc m_equal(DequeIterator<T> lhs, DequeIterator<T> rhs) -> int {
		if (lhs._deq != rhs._deq) return 0;
		return lhs._idx == rhs._idx;
	}
	
	proc m_not_equal(DequeIterator<T> lhs, DequeIterator<T> rhs) -> int {
		return not(lhs == rhs);
	}
	
	proc m_deref(DequeIterator<T> self) -> T {
		let __d = cast(deque<T>, self._deq);
		return __d~get(self._idx); 
	}
	
	proc deref_to(DequeIterator<T> self) -> T {
		return self~m_deref();
	}
}

impl deque<T> [new] {
	proc new<T>() -> deque<T> {
		return deque<T>(memalloc(8 * 4), 0, 0, 8);
	}

	proc empty(deque<T> self) -> int {
		return self.m_size == 0;
	}

	proc size(deque<T> self) -> int {
		return self.m_size;
	}

	proc phys_idx(deque<T> self, int logic_idx) -> int {
		return (self.m_head + logic_idx) % self.m_cap;
	}

	proc grow(deque<T> self) {
		let new_cap = self.m_cap * 2;
		let new_data = memalloc(new_cap * 4);
		
		let i = 0;
		while(i < self.m_size) {
			let p_idx = self~phys_idx(i);
			let val = rd32(self.m_data + (p_idx * 4));
			store32(new_data + (i * 4), val);
			i += 1;
		}

		memfree(self.m_data);
		self.m_data = new_data;
		self.m_cap = new_cap;
		self.m_head = 0; 
	}

	proc push_back(deque<T> self, T value) {
		if(self.m_size == self.m_cap) {
			self~grow();
		}
		let p_idx = self~phys_idx(self.m_size);
		store32(self.m_data + (p_idx * 4), value);
		self.m_size += 1;
	}

	proc push_front(deque<T> self, T value) {
		if(self.m_size == self.m_cap) {
			self~grow();
		}
		self.m_head = (self.m_head - 1 + self.m_cap) % self.m_cap;
		store32(self.m_data + (self.m_head * 4), value);
		self.m_size += 1;
	}

	proc pop_back(deque<T> self) -> T {
		if(self.m_size == 0) raise std::exception("deque::pop_back empty");
		self.m_size -= 1;
		let p_idx = self~phys_idx(self.m_size);
		return cast(T, rd32(self.m_data + (p_idx * 4)));
	}

	proc pop_front(deque<T> self) -> T {
		if(self.m_size == 0) raise std::exception("deque::pop_front empty");
		let val = cast(T, rd32(self.m_data + (self.m_head * 4)));
		self.m_head = (self.m_head + 1) % self.m_cap;
		self.m_size -= 1;
		return val;
	}

	proc get(deque<T> self, int index) -> T {
		let p_idx = self~phys_idx(index);
		return cast(T, rd32(self.m_data + (p_idx * 4)));
	}

	proc at(deque<T> self, int index) -> T {
		// ИСПРАВЛЕНО: замена >= на not(<)
		if(not(index < self.m_size)) raise std::exception("deque index out of bounds");
		if(index < 0) raise std::exception("deque index negative");
		return self~get(index);
	}
	
	proc front(deque<T> self) -> T {
		return self~at(0);
	}
	
	proc back(deque<T> self) -> T {
		if(self.m_size == 0) raise std::exception("deque empty");
		return self~get(self.m_size - 1);
	}

	proc begin(deque<T> self) -> DequeIterator<T> {
		return DequeIterator<T>(cast(ptr, self), 0);
	}

	proc end(deque<T> self) -> DequeIterator<T> {
		return DequeIterator<T>(cast(ptr, self), self.m_size);
	}

	proc destroy(deque<T> self) {
		#if(is_object_t(ct_type(T))) {
			let i = 0;
			try {
				while(i < self.m_size) {
					let val = self~get(i);
					delete val;
					i += 1;
				}
			} catch (err: exception) {
			}
		}
		memfree(self.m_data);
	}

	proc clone(deque<T> self) -> deque<T> {
		let new_deq = deque::new<T>();
		
		foreach_range(i, 0, self~size(), 1,
			new_deq~push_back(self~at(i));
		)
		
		return new_deq;
	}

	proc clear(deque<T> self) -> void {
		self.m_head = 0;
		self.m_size = 0;
	}

	proc m_assign(deque<T> self, deque<T> other) -> void {
		if (cast(ptr, self) == cast(ptr, other)) {
			return;
		}
		self~clear();
		foreach_range(i, 0, other~size(), 1,
			self~push_back(other~at(i));
		)
	}

	proc copy(deque<T> other) -> deque<T> {
		return other~clone();
	}

	proc m_assign(deque<T>& self, deque<T>&& other) -> void {
		std::__container_move(other, cast(deque<T>&&, self));
	}

	proc new<T>(deque<T>&& other) -> deque<T> {
		let __tmp: deque<T> = *cast(deque<T>&, other);
		store32(cast(ptr, other), null());
		return __tmp;
	}
}

namespace std {
	proc fprint<T>(int fd, deque<T> deq) {
		let __sz: int = deq.m_size;
		if(__sz == 0) {
			std::fprint(fd, "deque[]\n");
			return;
		}
		let i = 0;
		std::fprint(fd, "deque[");
		while(i < __sz) {
			std::fprint(fd, deq~get(i));
			if(i != (__sz - 1)) {
				std::fprint(fd, ", ");
			}
			i += 1;
		}
		std::fprint(fd, "]\n");
	}
	
	proc print<T>(deque<T> deq) {
		std::fprint(stdout, deq);
	}
}