// standarts streams
const stdin 0;
const stdout 1;
const stderr 2;

// characters
const NEWLINE 10;

// exit codes
const EXIT_SUCCESS 0;
const EXIT_FAILURE 1;

// booleans constants
const true 1;
const false 0;

#define rd32_as(__pointer __type) cast(__type, rd32(__pointer))$
#define rd16_as(__pointer __type) cast(__type, rd16(__pointer))$

#define neg(__as_positive_value) (0 - __as_positive_value)$

#define store32_any(__pointer __value)
	store32(__pointer, cast(int, __value))
$ // macro stores any 32 bit object/number/ptr

cextern "printf";

proc memcopy src:ptr dst:ptr size:int -> void {
	let i = 0;
	while(i < size) {
		store8(src + i, rd8(dst + i));
		i += 1;
	}
}

cextern "write";

proc write
	FileDesc:int // file descriptor
	data:ptr // data to write into file
	SizeToWrite:int // size to write data into file
-> int; // error code, 0 if success

proc memcpy src:ptr dst:ptr size:int -> void;

cextern "memcpy";

proc cmemcpy src:ptr dst:ptr size:int -> void
[nostdargs] {
	asm "push dword [ebp+16]";
	asm "push dword [ebp+12]";
	asm "push dword [ebp+8]";
	asm "call memcpy";
	asm "add esp, 12";
}

cextern "printf";

proc printf fstring:ptr -> void
[nosizedargs];

proc cputu number:int -> void
[nostdargs] {
	asm "push dword [ebp+8]";
	asm "push numfmtnl";
	asm "call printf";
	asm "add esp, 8";
}

#define nth_argv(__argv __nth)
	rd32_as(__argv + __nth * 4, ptr)
$