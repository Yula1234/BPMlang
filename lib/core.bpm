// standarts streams
const stdin 0;
const stdout 1;
const stderr 2;

// characters
const NEWLINE 10;

// exit codes
const EXIT_SUCCESS 0;
const EXIT_FAILURE 1;

// booleans constants
const true 1;
const false 0;

#define rd32_as(__pointer __type) cast(__type, rd32(__pointer))$
#define rd16_as(__pointer __type) cast(__type, rd16(__pointer))$

#define neg(__as_positive_value) (0 - __as_positive_value)$
#define typeid_of(__expr) typeid((__expr))$

#define __get(__array __index __elsize)
	cast(any, rd32(__array + (__index * __elsize)))$

#define __get_as(__array __index __type)
	cast(__type, __get(__array, __index, sizeof(__type)))$

#define __local_st(__buffer __struct)
	cast(__struct, &__buffer)$

#define not(__boolean)
	((__boolean) == 0)$

#define simple_cast(__stype __value)
	__expr_stmt {
		static_assert(ct_not(is_object_t(__value)), "`simple_cast` cannot cast from object type");
		__pushonstack(__value);
	} (__popfromstack())$

#define all_cast(__stype __value)
	cast(__stype, __value)$

#define object_cast(__stype __value)
	__expr_stmt {
		static_assert(is_object_t(__value), "`object_cast` cannot cast from non-object type");
		__pushonstack(__value);
	} (__popfromstack())$

#define foreach_range(__name __start __end __step __stmt)
	static_assert(is_same_t(__step,  ct_type(int)), "__step in `foreach_range` must be of type int");
	static_assert(is_same_t(__start, ct_type(int)), "__start in `foreach_range` must be of type int");
	static_assert(is_same_t(__end,   ct_type(int)), "__end in `foreach_range` must be of type int");
	{
		let __name = __start;
		while(__name < (__end)) {
			__stmt
			__name += __step;
		}
	}$

#define null cast(ptr, 0)$

#define store32_any(__pointer __value)
	store32(__pointer, cast(int, __value))
$ // macro stores any 32 bit object/number/ptr

cextern "printf";
cextern "fprintf";
cextern "sprintf";

proc sprintf p:ptr fstr:ptr -> void
[nosizedargs];

proc printf fstring:ptr -> void
[nosizedargs];

proc fprintf fd:ptr fstring:ptr -> void
[nosizedargs];

proc memcopy src:ptr dst:ptr size:int -> void {
	let i = 0;
	while(i < size) {
		store8(src + i, rd8(dst + i));
		i += 1;
	}
}

proc memset src:ptr value:int size:int -> void {
	if((size % 4) == 0) {
		let __dword = (size / 4);
		let __i = 0;
		let __idw = 0;
		while(__i < __dword) {
			store32(src + __idw, value);
			__i += 1;
			__idw += 4;
		}
	}
	else {
		let i = 0;
		while(i < size) {
			store8(src + i, value);
			i += 1;
		}
	}
}

cextern "write";

proc write
	FileDesc:int // file descriptor
	data:ptr // data to write into file
	SizeToWrite:int // size to write data into file
-> int; // error code, 0 if success

proc memcpy src:ptr dst:ptr size:int -> void;

cextern "memcpy";

proc cmemcpy src:ptr dst:ptr size:int -> void
[nostdargs] {
	asm "push dword [ebp+16]";
	asm "push dword [ebp+12]";
	asm "push dword [ebp+8]";
	asm "call memcpy";
	asm "add esp, 12";
}

proc cputu number:int -> void
[nostdargs] {
	asm "push dword [ebp+8]";
	asm "push numfmtnl";
	asm "call printf";
	asm "add esp, 8";
}

proc __seg_crash -> void {
	store32(null(), 0);
}

proc __seg_crash_mess __message:ptr -> void {
	printf("%s\n", __message);
	__seg_crash();
}

#define crash() __seg_crash()$
#define __exception(__message)
	__seg_crash_mess(__message)$

#define nth_argv(__argv __nth)
	__expr_stmt {
		static_assert(is_same_t(__nth, ct_type(int)), "`nth_argv` second arg `__nth` except type `int`");
		static_assert(is_same_t(__nth, ct_type(ptr)), "`nth_argv` first arg `__argv` except type `ptr`");
	} (rd32_as(__argv + __nth * 4, ptr))$