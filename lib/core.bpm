// standarts streams
const stdin 0;
const stdout 1;
const stderr 2;

// characters
const NEWLINE 10;

// exit codes
const EXIT_SUCCESS 0;
const EXIT_FAILURE 1;

// booleans constants
const true 1;
const false 0;

#define dup() asm "push dword [esp]"$

#define NOT_IMPLEMENTED() static_assert(false, "not implemented")$

#define rd32_as(__pointer __type) cast(__type, rd32(__pointer))$
#define rd16_as(__pointer __type) cast(__type, rd16(__pointer))$

#define neg(__as_positive_value) (0 - (__as_positive_value))$
#define typeid_of(__expr) typeid((__expr))$

#define __get(__array __index __elsize)
	cast(any, rd32(__array + (__index * __elsize)))$

#define __get_as(__array __index __type)
	cast(__type, __get(__array, __index, sizeof(__type)))$

#define __local_st(__buffer __struct)
	cast(__struct, &__buffer)$

#define not(__boolean)
	((__boolean) == 0)$

#define simple_cast(__stype __value)
	__expr_stmt {
		static_assert(ct_not(is_object_t(__value)), "`simple_cast` cannot cast from object type");
		__pushonstack(__value);
	} (cast(__stype, __popfromstack()))$

#define all_cast(__stype __value)
	cast(__stype, __value)$

#define object_cast(__stype __value)
	__expr_stmt {
		static_assert(is_object_t(__value), "`object_cast` cannot cast from non-object type");
		__pushonstack(__value);
	} (cast(__stype, __popfromstack()))$

#define __stdmove(__P1 __P2)
	static_assert(is_same_t(__P1, __P2), "at `__stdmove` except 2 identical types");
	#if(is_object_t(__P1)) { delete __P1; }
	#if(is_same_t(__P1, ct_type(ptr))) {
		store32_any(__P1, rd32(__P2));
	} else { store32_any(&(__P1), __P2); }
	store32(&(__P2), 0)$

#define stdmove(__P_v)
	__expr_stmt  {
		__pushonstack(__P_v);
		store32(&(__P_v), 0);
	} (cast_to(__P_v, __popfromstack()))$

cextern "malloc";
cextern "free";
proc malloc SizeToAlloc:int -> ptr;
proc free Pointer:ptr -> void;

proc memcpy src:ptr dst:ptr size:int -> void;
cextern "memcpy";

proc __stdcopy_v __A_Parg:any __A_Sarg:int -> ptr {
	let __cm = malloc(__A_Sarg);
	memcpy(__cm, cast(ptr, __A_Parg), __A_Sarg);
	return __cm;
}

#define stdcopy(__P1)
	__expr_stmt {
		#if(is_object_t(__P1)) {
			__pushonstack(__stdcopy_v(__P1, sizeof((__P1))));
		} else {
			__pushonstack(__P1);
		}
	} (cast_to(__P1, __popfromstack()))
$

#define foreach_range(__name __start __end __step __stmt)
	static_assert(is_same_t(__step,  ct_type(int)), "__step in `foreach_range` must be of type int");
	static_assert(is_same_t(__start, ct_type(int)), "__start in `foreach_range` must be of type int");
	static_assert(is_same_t(__end,   ct_type(int)), "__end in `foreach_range` must be of type int");
	{
		let __name = __start;
		while(__name < (__end)) {
			__stmt
			__name += __step;
		}
	}$

#define null cast(ptr, 0)$

#define store32_any(__pointer __value)
	store32(__pointer, cast(int, __value))
$ // macro stores any 32 bit object/number/ptr

cextern "printf";
cextern "fprintf";
cextern "sprintf";

proc sprintf p:ptr fstr:ptr -> void
[nosizedargs];

proc printf fstring:ptr -> void
[nosizedargs];

proc fprintf fd:ptr fstring:ptr -> void
[nosizedargs];

proc memcopy src:ptr dst:ptr size:int -> void {
	let i = 0;
	while(i < size) {
		store8(src + i, rd8(dst + i));
		i += 1;
	}
}

proc memset src:ptr value:int size:int -> void {
	if((size % 4) == 0) {
		let __dword = (size / 4);
		let __i = 0;
		let __idw = 0;
		while(__i < __dword) {
			store32(src + __idw, value);
			__i += 1;
			__idw += 4;
		}
	}
	else {
		let i = 0;
		while(i < size) {
			store8(src + i, value);
			i += 1;
		}
	}
}

cextern "write";

proc write
	FileDesc:int // file descriptor
	data:ptr // data to write into file
	SizeToWrite:int // size to write data into file
-> int; // error code, 0 if success

proc cmemcpy src:ptr dst:ptr size:int -> void
[nostdargs] {
	asm "push dword [ebp+16]";
	asm "push dword [ebp+12]";
	asm "push dword [ebp+8]";
	asm "call memcpy";
	asm "add esp, 12";
}

proc cputu number:int -> void
[nostdargs] {
	asm "push dword [ebp+8]";
	asm "push numfmtnl";
	asm "call printf";
	asm "add esp, 8";
}

proc __seg_crash -> void {
	store32(null(), 0);
}

proc __seg_crash_mess __message:ptr -> void {
	printf("%s\n", __message);
	__seg_crash();
}

#define crash() __seg_crash()$
#define __exception(__message)
	__seg_crash_mess(__message)$

#define nth_argv(__argv __nth)
	__expr_stmt {
		static_assert(is_same_t(__nth, ct_type(int)), "`nth_argv` second arg `__nth` except type `int`");
		static_assert(is_same_t(__argv, ct_type(ptr)), "`nth_argv` first arg `__argv` except type `ptr`");
	} (rd32_as(__argv + (__nth * 4), ptr))$