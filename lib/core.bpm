// standarts streams
const stdin  = 0;
const stdout = 1;
const stderr = 2;

const NEWLINE = 10;

// exit codes
const EXIT_SUCCESS = 0;
const EXIT_FAILURE = 1;

// booleans constants
const true  = 1;
const false = 0;

#define call_ptr(__p)
	__expr_stmt {
		__pushonstack(__p);
		asm "pop ebx";
		asm "call ebx";
		asm "push eax";
	} (__popfromstack())
$

#define __frame_ebp()
	__expr_stmt {
		asm "push ebp";
	} (cast(int, __popfromstack()))$

#define dup() asm "push dword [esp]"$

cextern "get_cstdout";
cextern "get_cstdin";
cextern "get_cstderr";
proc get_cstdout() -> ptr;
proc get_cstdin() ->  ptr;
proc get_cstderr() -> ptr;

#define rd32_as(__pointer __type) cast(__type, rd32(__pointer))$
#define rd16_as(__pointer __type) cast(__type, rd16(__pointer))$

#define neg(__as_positive_value) (0 - (__as_positive_value))$
#define typeid_of(__expr) typeid((__expr))$

#define not(__boolean)
	((__boolean) == 0)$

cextern "malloc";
cextern "free";
proc malloc(int SizeToAlloc) -> ptr;
proc free(ptr Pointer) -> void;

proc memalloc(int SizeToAlloc) -> ptr;
proc memfree(ptr Pointer) -> void;
proc dump_all_chunks() -> void;

proc memcpy(ptr src, ptr dst, int size) -> void;

cextern "memcmp";
proc memcmp(ptr ptr1, ptr ptr2, int num) -> int;

cextern "memmove";
proc memmove(ptr dst, ptr src, int size) -> void;

#define foreach_range(__name __start __end __step __stmt)
	static_assert(is_same_t(__step,  ct_type(int)), "__step in `foreach_range` must be of type int");
	static_assert(is_same_t(__start, ct_type(int)), "__start in `foreach_range` must be of type int");
	static_assert(is_same_t(__end,   ct_type(int)), "__end in `foreach_range` must be of type int");
	{
		let __name = __start;
		while(__name < (__end)) {
			__stmt
			__name += __step;
		}
	}$

#define null cast(ptr, 0)$

cextern "printf";
cextern "fprintf";
cextern "sprintf";
proc sprintf(ptr p, char* fstr)     -> void [nosizedargs];
proc printf(char* fstring)          -> void [nosizedargs];
proc fprintf(ptr fd, char* fstring) -> void [nosizedargs];

cextern "memset";
proc memset(ptr mem, int val, int size) -> void;

namespace std {
	proc memcpy(ptr src, ptr dst, int size) = memcpy(src, dst, size);
	proc memset(ptr src, int value, int size) -> void {
		if((size % 4) == 0) {
			let __dword = (size / 4);
			let __i = 0;
			let __idw = 0;
			while(__i < __dword) {
				store32(src + __idw, value);
				__i += 1;
				__idw += 4;
			}
		}
		else {
			let i = 0;
			while(i < size) {
				store8(src + i, value);
				i += 1;
			}
		}
	}
}

cextern "write";
proc write(int fd, char* data, int size) -> int;

namespace std {
	proc nth_argv(char** __argv, int __nth) -> char* =
		return rd32_as(__argv + (__nth * 4), char*);
}