include "core"
include "string"

proc fabs number:int -> int {
	if(0 > number)
	{ return number - number + number; }
	return number;
}

proc fputs
	fd:int // File Descriptor
	string:ptr // string to put into a file
-> void {
	write(fd, string, strlen(string));
}

proc puts string:ptr -> void {
	fputs(stdout, string);
}

const UTOS_BUFFER_CAPACITY 128;

proc tmp_utos src:ptr number:int -> int {
	let i = 0;
	let result = number;
	buffer bf(UTOS_BUFFER_CAPACITY);
	while(result != 0) {
		store8(&bf + i, (result % 10) + '0');
		result /= 10;
		i += 1;
	}
	memcopy(src, &bf, i);
	return i;
}

proc utos src:ptr number:int -> void {
	if(number == 0) {
		store8(src, 48);
		store8(src + 1, 0);
		return;
	}
	let i = 0;
	let strsize_i = tmp_utos(src, number);
	let strsize_m = strsize_i - 1;
	buffer tmpb(UTOS_BUFFER_CAPACITY);
	memcopy(&tmpb, src, strsize_i);
	while(i < strsize_i) {
		store8(src + i, rd8(&tmpb + strsize_m));
		strsize_m -= 1;
		i += 1;
	}
	store8(src + strsize_i, 0);
}

proc stou str:ptr -> int {
	let i = 0;
	let result = 0;
	while(rd8(str + i) != 0) {
		result = (rd8(str + i) - '0') + (result * 10);
		i += 1;
	}
	return result;
}

proc fputc fd:int chr:int -> void {
	buffer bf(2);
	store8(&bf, chr);
	store8(&bf + 1, 0);
	write(fd, &bf, 1);
}

proc putc chr:int -> void {
	fputc(stdout, chr);
}

const FPUTU_BUFFER_CAPACITY 128;

proc fputuwnl fd:int number:int -> void {
	buffer tmp(FPUTU_BUFFER_CAPACITY);
	utos(&tmp, number);
	fputs(fd, &tmp);
}

proc fputu fd:int number:int -> void {
	buffer tmp(FPUTU_BUFFER_CAPACITY);
	utos(&tmp, number);
	fputs(fd, &tmp);
	fputc(fd, NEWLINE);
}

proc putuwnl number:int -> void {
	fputuwnl(stdout, number);
}

proc putu number:int -> void {
	fputu(stdout, number);
}

proc nth_arg_int frame:int nth:int -> int
[nostdargs] {
	asm "mov ecx, dword [ebp+8]";
	asm "mov edx, dword [ebp+12]";
	asm "imul edx, 4";
	asm "add edx, 8";
	asm "mov eax, dword [ecx+edx]";
}

#define nth_arg_as(__frame __nth __type) cast(__type, nth_arg_int(__frame, __nth))$

proc format_fprint_frame fd:int frame:int format_str:ptr -> void
[nosizedargs] {
	let nth = 1;
	let i = 0;
	while(rd8(format_str + i) != 0) {
		if(rd8(format_str + i) == '%') {
			if(rd8(format_str + (i + 1)) == 'd') {
				i += 1;
				fputuwnl(fd, nth_arg_int(frame, nth));
				nth += 1;
			}
			elif(rd8(format_str + (i + 1)) == 's') {
				i += 1;
				fputs(fd, nth_arg_as(frame, nth, ptr));
				nth += 1;
			} elif(rd8(format_str + (i + 1)) == 'c') {
				i += 1;
				fputc(fd, nth_arg_int(frame, nth));
				nth += 1;
			} else {
				fputc(fd, rd8(format_str + i));
			}
		} else {
			fputc(fd, rd8(format_str + i));
		}
		i += 1;
	}
}

proc format_fprint fd:int format_str:ptr -> void
[nosizedargs] {
	let frame = 0;
	asm "mov dword [ebp-12], ebp";
	asm "add dword [ebp-12], 4";
	format_fprint_frame(fd, frame, format_str);
}

proc format_print format_str:ptr -> void
[nosizedargs] {
	let frame = 0;
	asm "mov dword [ebp-8], ebp";
	format_fprint_frame(stdout, frame, format_str);
}

#define assert(__expr __message)
	static_assert(is_same_t(__message, ct_type(ptr)), "`assert` __message must be of type `ptr`");
	if(not(__expr)) {
		format_print("%s:%d:%d AssertionFailed: %s\n", __FILE__, __LINE__, __COL__, __message);
		exit(1);
	}
	__empty_stmt$

cextern "scanf";

proc input_number addr:ptr -> void
[nostdargs] {
	asm "push dword [ebp+8]";
	asm "push numfmt";
	asm "call scanf";
	asm "add esp, 8";
}

proc input_string addr:ptr -> void
[nostdargs] {
	asm "push dword [ebp+8]";
	asm "push strfmt";
	asm "call scanf";
	asm "add esp, 8";
}

proc scanf format_str:ptr -> void [nosizedargs];