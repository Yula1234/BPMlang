// standarts streams
const stdin 0;
const stdout 1;
const stderr 2;

// booleans constants
const true 1;
const false 0;

proc strlen str:ptr -> int {
	let i = 0;
	while(rd8(str + i) != 0) {
		i = i + 1;
	}
	return i;
}

proc memcpy src:ptr dst:ptr size:int -> void {
	let i = 0;
	while(i < size) {
		store8(src + i, rd8(dst + i));
		i = i + 1;
	}
}

proc tmp_utos src:ptr number:int -> int {
	let i = 0;
	let result = number;
	buffer bf(256);
	while(result != 0) {
		store8(&bf + i, (result % 10) + '0');
		result = result / 10;
		i = i + 1;
	}
	memcpy(src, &bf, i);
	return i;
}

proc utos src:ptr number:int -> void {
	if(number == 0) {
		store8(src, 48);
		store8(src + 1, 0);
		asm "add esp, 148";
		asm "pop ebp";
		asm "ret";
	}
	let i = 0;
	let strsize_i = tmp_utos(src, number);
	let strsize_m = strsize_i - 1;
	buffer tmpb(128);
	memcpy(&tmpb, src, strsize_i);
	store8(&tmpb + strsize_i, 0);
	while(i < strsize_i) {
		store8(src + i, rd8(&tmpb + strsize_m));
		strsize_m = strsize_m - 1;
		i = i + 1;
	}
}

cextern "write";

proc wrapper_write
	FileDesc:int // file descriptor
	data:ptr // data to write into file
	SizeToWrite:int // size to write data into file
-> int // error code, 0 if success
[
	nostdargs // nostdargs is a say
			  // to a compiller dont generate arguments
] // procedure attributes
{
	asm "push dword [ebp+16]"; // pushing SizeToWrite
	asm "push dword [ebp+12]"; // pushing data
	asm "push dword [ebp+8]"; // pushing FileDesc
	asm "call write"; // error code stored in eax
	// if procedure uses as expr eax returned
	asm "add esp, 12";
}

proc fputs
	fd:int // File Descriptor
	string:ptr // string to put into a file
-> void {
	wrapper_write(fd, string, strlen(string));
}

proc puts string:ptr -> void {
	fputs(stdout, string);
}

proc fputuwnl fd:int number:int -> void {
	buffer tmp(256);
	utos(&tmp, number);
	fputs(fd, &tmp);
}

proc fputu fd:int number:int -> void {
	buffer tmp(256);
	utos(&tmp, number);
	fputs(fd, &tmp);
	fputs(fd, "\n");
}

proc putuwnl number:int -> void {
	fputuwnl(stdout, number);
}

proc putu number:int -> void {
	fputu(stdout, number);
}

proc streq str1:ptr str2:ptr -> int {
	asm "mov ecx, dword [ebp-4]";
	asm "mov edx, dword [ebp-8]";
	asm "xor ebx, ebx";
	asm ".next_iter:";
	asm "cmp byte [ecx+ebx], 0";
	asm "jz .true";
	asm "cmp byte [edx+ebx], 0";
	asm "jz .true";
	asm "xor eax, eax";
	asm "mov al, byte [edx+ebx]";
	asm "cmp byte [ecx+ebx], al";
	asm "jnz .false";
	asm "inc ebx";
	asm "jmp .next_iter";
	asm ".false:";
	return false;
	asm ".true:";
	return true;
}

cextern "malloc";
cextern "free";

proc memalloc Size:int -> ptr 
[nostdargs] {
	asm "push dword [ebp+8]";
	asm "call malloc";
	asm "add esp, 4";
}

proc memfree Mem:ptr -> void 
[nostdargs] {
	asm "push dword [ebp+8]";
	asm "call free";
	asm "add esp, 4";
}

proc nth_arg_int frame:int nth:int -> int
[nostdargs] {
	asm "mov ecx, dword [ebp+8]";
	asm "mov edx, dword [ebp+12]";
	asm "imul edx, 4";
	asm "add edx, 8";
	asm "mov eax, dword [ecx+edx]";
}

proc nth_arg_ptr frame:int nth:int -> ptr
[nostdargs] {
	asm "mov ecx, dword [ebp+8]";
	asm "mov edx, dword [ebp+12]";
	asm "imul edx, 4";
	asm "add edx, 8";
	asm "mov eax, dword [ecx+edx]";
}

proc fputc fd:int chr:int -> void {
	buffer bf(2);
	store8(&bf, chr);
	store8(&bf + 1, 0);
	wrapper_write(fd, &bf, 1);
}

proc putc chr:int -> void {
	fputc(stdout, chr);
}

proc format_fprint fd:int format_str:ptr -> void
[nosizedargs] {
	let frame = 0;
	asm "mov dword [ebp-12], ebp";
	let nth = 2;
	let i = 0;
	while(rd8(format_str + i) != 0) {
		if(rd8(format_str + i) == '%') {
			if(rd8(format_str + (i + 1)) == 'd') {
				i = i + 1;
				fputuwnl(fd, nth_arg_int(frame, nth));
				nth = nth + 1;
			}
			elif(rd8(format_str + (i + 1)) == 's') {
				i = i + 1;
				fputs(fd, nth_arg_ptr(frame, nth));
				nth = nth + 1;
			} elif(rd8(format_str + (i + 1)) == 'c') {
				i = i + 1;
				fputc(fd, nth_arg_int(frame, nth));
				nth = nth + 1;
			} else {
				fputc(fd, rd8(format_str + i));
			}
		} else {
			fputc(fd, rd8(format_str + i));
		}
		i = i + 1;
	}
}

proc format_fprint_frame fd:int frame:int format_str:ptr -> void
[nosizedargs] {
	let nth = 1;
	let i = 0;
	while(rd8(format_str + i) != 0) {
		if(rd8(format_str + i) == '%') {
			if(rd8(format_str + (i + 1)) == 'd') {
				i = i + 1;
				fputuwnl(fd, nth_arg_int(frame, nth));
				nth = nth + 1;
			}
			elif(rd8(format_str + (i + 1)) == 's') {
				i = i + 1;
				fputs(fd, nth_arg_ptr(frame, nth));
				nth = nth + 1;
			} elif(rd8(format_str + (i + 1)) == 'c') {
				i = i + 1;
				fputc(fd, nth_arg_int(frame, nth));
				nth = nth + 1;
			} else {
				fputc(fd, rd8(format_str + i));
			}
		} else {
			fputc(fd, rd8(format_str + i));
		}
		i = i + 1;
	}
}

proc format_print format_str:ptr -> void
[nosizedargs] {
	let frame = 0;
	asm "mov dword [ebp-8], ebp";
	format_fprint_frame(stdout, frame, format_str);
}