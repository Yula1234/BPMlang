include "std"

struct DynamicArray {
	size:int,
	capacity:int,
	data:ptr
}

interface IDynarray {
	size:int,
	capacity:int,
	data:ptr
}

#define __dynarray_ctor(__struct __name)
	proc __name _A_scapacity:int -> __struct {
		return __struct(0, _A_scapacity, malloc(_A_scapacity * 4));
	}
	__empty_stmt$

proc dtor_dynarray da:IDynarray -> void {
	free(da.data);
}

#define __dynarray_dtor(__struct __name)
	proc __name self:__struct -> void {
		dtor_dynarray(self);
	}
	__empty_stmt$

__dynarray_dtor(DynamicArray, __dtor__DynamicArray);
__dynarray_ctor(DynamicArray, new_dynarray);

proc delete_dynarray da:IDynarray -> void {
	free(da.data);
	delete da;
}

proc dynarray_extend da:IDynarray -> void {
	let tmp = malloc((da.capacity * 4) * 2);
	memcpy(tmp, da.data, da.size * 4);
	free(da.data);
	da.capacity = da.capacity * 2;
	da.data = tmp;
}

proc dynarray_push da:IDynarray _A_value:any -> void {
	let value_as_i32 = cast(int, _A_value);
	if(da.size == da.capacity) {
		dynarray_extend(da);
	}
	store32(da.data + (da.size * 4), value_as_i32);
	da.size += 1;
}

proc dynarray_get da:IDynarray index:int -> any {
	return rd32(da.data + (index * 4));
}

proc dynarray_pop da:IDynarray -> any {
	let _result = dynarray_get(da, da.size - 1);
	da.size -= 1;
	return _result;
}

proc dynarray_is_empty da:IDynarray -> int {
	return da.size == 0;
}

proc dynarray_front da:IDynarray -> any {
	return dynarray_get(da, 0);
}

proc dynarray_back da:IDynarray -> any {
	return dynarray_get(da, da.size - 1);
}

proc dynarray_addr_of da:IDynarray index:int -> ptr {
	return cast(ptr, da.data + (index * 4));
}

proc dynarray_insert da:IDynarray index:int _value:any -> void {
	let value_as_i32 = cast(int, _value);
	if(da.size == 0) {
		dynarray_push(da, _value);
		return;
	}
	if(da.size == da.capacity) {
		dynarray_extend(da);
	}
	memcpy(dynarray_addr_of(da, index + 1), dynarray_addr_of(da, index), (da.size * 4) - (index * 4));
	store32(dynarray_addr_of(da, index), value_as_i32);
	da.size += 1;
}

proc dynarray_erase da:IDynarray index:int -> void {
	memcpy(dynarray_addr_of(da, index), dynarray_addr_of(da, index + 1), (da.size * 4) - (index * 4));
	da.size -= 1;
}

proc dynarray_clear da:IDynarray -> void {
	da.size = 0;
}

proc dynarray_set da:IDynarray index:int _value:any -> void {
	let value_as_i32 = cast(int, _value);
	store32(dynarray_addr_of(da, index), value_as_i32);
}

proc dynarray_print da:IDynarray -> void {
	let size = da.size;
	puts("[");
	let i = 0;
	while(i < size) {
		putuwnl(cast(int, dynarray_get(da, i)));
		if(i != (size - 1)) {
			puts(", ");
		}
		i += 1;
	}
	puts("]\n");
}

#define dynarray_get_as(__dynarray __index __type) cast(__type, dynarray_get(__dynarray, __index))$

#define foreach_dynarray(__dynarray __type __stmt)
	{
		let __i = 0;
		let __value: __type;
		while(__i < __dynarray.size) {
			__value = dynarray_get_as(__dynarray, __i, __type); 
			__stmt
			__i += 1;
		}
	}$ /*
		macro make basic-loop for all elements
		in dynamic array.
		in context you can use `__i` and `__value`.
		`__i` is current iteration number,
		`__value` is current value in array nth __i.

		example:
		let Dynarray = new_dynarray(12);
		{
			let i = 0;
			while(i < 5) {
			dynarray_push(Dynarray, i);
				i += 1;
			}
		}
		foreach_dynarray(Dynarray, int, {
			putu(__value);
		})
		delete_dynarray(Dynarray);
		output:
		0
		1
		2
		3
		4
*/