namespace std {
	proc find_if<Iter, T>(Iter begin, Iter end, ProcPtr<int, T> pred) -> Iter {
		static_assert(is_same_t(*begin, ct_type(T)), "std::find_if(Iter<T>, Iter<T>, ProcPtr<int, T>) except that *Iter return -> T");
		let __it: Iter = begin;
		while(__it != end) {
			let __fres = pred(*__it);
			if(__fres) return __it;
			__it += 1;
		}
		return end;
	}
	proc find<Iter, T>(Iter begin, Iter end, T value) -> Iter {
		static_assert(is_same_t(*begin, ct_type(T)), "std::find(Iter<T>, Iter<T>, T) except that *Iter return -> T");
		let __it: Iter = begin;
		while(__it != end) {
			if(*__it == value) return __it;
			__it += 1;
		}
		return end;
	}
	proc distance<Iter>(Iter begin, Iter end) -> int {
		let __it: Iter = begin;
		let __counter: int = 0;
		while(__it != end) {
			__counter += 1;
			__it += 1;
		}
		return __counter;
	}
	proc copy_range<Iter, Iter2>(Iter src, Iter2 begin, Iter2 end) {
		let __it: Iter2 = begin;
		let __input: Iter = src;
		while(__it != end) {
			*__input = __it.deref_to();
			__input += 1;
			__it += 1;
		}
	}
	proc copy_if_range<Iter, Iter2, T>(Iter src, Iter2 begin, Iter2 end, ProcPtr<int, T> pred) -> Iter {
		let __it: Iter2 = begin;
		let __input: Iter = src;
		while(__it != end) {
			let __fres = pred(*__it);
			if(__fres) {
				*__input = *__it;
				__input += 1;
			}
			__it += 1;
		}
		return __input;
	}
}