# Документация языка BPMlang (v2.0)

**bpmlang** — это статически типизированный, компилируемый язык программирования общего назначения с автоматическим управлением памятью (GC) и ссылочной моделью объектов.

Язык компилируется в 32-битный ассемблер (NASM x86), затем в объектный код, и линкуется с использованием GCC.

## Содержание
1. [Модель памяти и Типы данных](#1-модель-памяти-и-типы-данных)
2. [Переменные и Константы](#2-переменные-и-константы)
3. [Функции и Процедуры](#3-функции-и-процедуры)
4. [Управляющие конструкции](#4-управляющие-конструкции)
5. [Структуры и ООП](#5-структуры-и-ооп)
6. [Интерфейсы и Полиморфизм](#6-интерфейсы-и-полиморфизм)
7. [Шаблоны (Generics)](#7-шаблоны-generics)
8. [Обработка исключений](#8-обработка-исключений)
9. [Управление памятью](#9-управление-памятью)
10. [Препроцессор](#10-препроцессор)
11. [Низкоуровневые возможности](#11-низкоуровневые-возможности)
12. [Пример работы со строками и памятью](#Пример-работы-со-строками-и-памятью)

---

## 1. Модель памяти и Типы данных

### 1.1 Унифицированный размер типа
Фундаментальная особенность **bpmlang**: **любой тип данных занимает ровно 4 байта (32 бита)**.
Это касается как примитивов (`int`, `char`), так и сложных структур (`string`, `vector`).

### 1.2 Ссылочная семантика
*   **Примитивы (`int`, `char`)**: Хранятся по значению (вмещаются в 4 байта).
*   **Объекты (`struct`)**: Хранятся **по ссылке**. Переменная типа структуры хранит не сами данные, а **указатель** на область памяти в куче (Managed Heap), где лежат поля структуры.
    *   Присваивание `a = b` копирует ссылку (поверхностная копия).
    *   Для глубокого копирования используется метод `.clone()` (если реализован).

### 1.3 Базовые типы
| Тип | Описание | Размер |
| :--- | :--- | :--- |
| `int` | 32-битное знаковое целое. | 4 байта |
| `char` | 32-битное целое (хранит код символа). В памяти строк упаковывается до 1 байта. | 4 байта |
| `void` | Отсутствие значения (для возвращаемых типов). | 0 байт (в рантайме не существует) |
| `ptr` | Нетипизированный указатель (аналог `void*`). | 4 байта |
| `any` | Тип, стирающий информацию о конкретном типе (используется для RTTI). | 4 байта |

### 1.4 Указатели и Ссылки
*   `T*`: Указатель на тип `T`. Используется для арифметики указателей и взаимодействия с C.
*   `T&`: Ссылка (l-value). Обычно используется для передачи "адреса переменной, хранящей ссылку на объект".
*   `T&&`: R-value ссылка. Используется для семантики перемещения (Move semantics).

---

## 2. Переменные и Константы

### 2.1 Переменные (`let`)
Поддерживается вывод типов.
```bpm
let a = 10;             // Тип: int
let b: int = 20;        // Явное указание
let s: string;          // Объявление (значение по умолчанию: null/0)
let ptr_v = &a;         // Взятие адреса (тип int*)
```

### 2.2 Константы (`const`)
Константы должны быть известны на этапе компиляции.
```bpm
const MAX_BUFFER = 1024;
const SUCCESS = 0;
```

---

## 3. Функции и Процедуры

Объявляются ключевым словом `proc`.

### 3.1 Синтаксис
```bpm
// Базовая форма
proc sum(int a, int b) -> int {
    return a + b;
}

// Однострочная форма (Expression body)
proc square(int x) -> int = return x * x;

// Процедура (возвращает void)
proc hello() {
    std::print("Hello");
}
```

### 3.2 Атрибуты (Attributes)
Атрибуты управляют кодогенерацией и соглашениями о вызовах.
*   `[nosizedargs]`: Отключает проверку количества аргументов. Используется для функций с переменным числом аргументов (varargs), таких как `printf`. Реализация таких функций требует ручного разбора стека.
*   `[nostdargs]`: Отключает генерацию стандартного пролога функции (сохранение `ebp` и копирование аргументов в локальные переменные).
*   `[cimport]`: Указывает, что функция находится во внешней библиотеке (C runtime) и не имеет тела в текущем файле.

```bpm
cextern "printf";
proc printf(char* fmt) -> void [nosizedargs];
```

---

## 4. Управляющие конструкции

### 4.1 Условия
```bpm
if (condition) {
    // ...
} elif (other_condition) {
    // ...
} else {
    // ...
}
```

### 4.2 Циклы
*   **while**:
    ```bpm
    while (i < 10) { ... }
    ```
*   **for**: Классический C-style цикл.
    ```bpm
    for (let i = 0; i < 10; i += 1) { ... }
    ```
*   **foreach**: Синтаксический сахар.
    ```bpm
    // Требует наличия методов begin(), end(), а у итератора: m_inc(), m_deref(), m_equal().
    foreach (let val : container) {
        std::print(val);
    }
    ```

Поддерживаются операторы `break` и `return`.

---

## 5. Структуры и ООП

В языке нет классов, но есть структуры с методами.

### 5.1 Определение данных (`struct`)
```bpm
struct Vector3 {
    x: int,
    y: int,
    z: int
}
```
*При создании `Vector3` в памяти выделяется 12 байт (3 * 4), а переменная хранит указатель на этот блок.*

### 5.2 Реализация методов (`impl`)
```bpm
impl Vector3 {
    // Статический метод (конструктор)
    // Атрибут [new] подсказывает компилятору, что это конструктор (опционально)
    proc new(int x, int y, int z) -> Vector3 {
        // Конструктор структуры вызывается как функция с именем структуры
        return Vector3(x, y, z); 
    }

    // Метод экземпляра (первый аргумент - self)
    proc length_sq(Vector3 self) -> int {
        return (self.x * self.x) + (self.y * self.y) + (self.z * self.z);
    }
}
```

### 5.3 Перегрузка операторов
Операторы перегружаются путем реализации специальных методов в блоке `impl`.

| Оператор | Метод | Описание |
| :--- | :--- | :--- |
| `+` | `m_add` | Сложение |
| `-` | `m_sub` | Вычитание |
| `*` | `m_mul` | Умножение |
| `/` | `m_div` | Деление |
| `<<`, `>>` | `m_shl`, `m_shr` | Битовые сдвиги |
| `==` | `m_equal` | Сравнение на равенство |
| `!=` | `m_not_equal` | Неравенство |
| `+=`, `-=`... | `m_inc`, `m_dec`... | Составное присваивание |
| `[]` | `m_index` | Чтение по индексу |
| `[]` (l-value) | `m_index_ref` | Запись по индексу (должен возвращать `T&` или `ptr`) |
| `*x` (deref) | `m_deref` | Разыменование (для итераторов и умных указателей) |
| `=` | `m_assign` | Копирование или перемещение |

---

## 6. Интерфейсы и Полиморфизм

Интерфейсы определяют контракт. Реализация неявная (Duck Typing на этапе компиляции шаблонов или явный vtable boxing).

```bpm
interface Printable {
    proc m_fprint(self, int fd);
}
```

### Динамическая диспетчеризация (Boxing)
Если переменная имеет тип интерфейса, объект "упаковывается": создается структура, хранящая указатель на реальный объект и таблицу виртуальных функций (VTable) для методов интерфейса.

```bpm
proc print_any(Printable obj) {
    obj.m_fprint(stdout); // Вызов через VTable
}
```

---

## 7. Шаблоны (Generics)

Язык поддерживает параметрический полиморфизм через **мономорфизацию**. Для каждой комбинации типов-аргументов компилятор генерирует уникальную версию функции или структуры.

```bpm
struct pair<T, U> {
    first: T,
    second: U
}

impl pair<T, U> {
    proc swap(pair<T, U> self) {
        // ...
    }
}
```

### Ограничения шаблонов (Constraints)
Можно требовать, чтобы тип реализовывал определенный интерфейс:
```bpm
proc sort<T: Comparable>(vector<T> v) { ... }
```

---

## 8. Обработка исключений

Используется модель `try-catch`, реализованная через `setjmp`/`longjmp` и глобальный стек обработчиков.

```bpm
try {
    if (file_not_found) {
        // Выбрасывание исключения (объект в куче)
        raise std::exception("File error");
    }
} catch (e: std::exception) {
    // Переменная 'e' доступна в блоке
    printf("Error: %s\n", e.what());
}
```
*   Поддерживается перехват системных ошибок (например, `Segmentation Fault`), которые оборачиваются в `__SigSegvException`.
*   Встроенная трассировка стека (Traceback).

---

## 9. Управление памятью

В языке работает **Mark-and-Sweep Garbage Collector (GC)**.

*   **Аллокация:** `memalloc(size)` или создание структур через конструктор. Память запрашивается у GC. Если лимит исчерпан, запускается сборка мусора ("Stop the world"), сканирующая стек и кучу.
*   **Деаллокация:** Автоматическая.
*   **Ручное управление (Unsafe):** Можно использовать `malloc`/`free` (из libc) для объектов, которые не должны управляться GC (например, внутренние буферы `vector` или `string`, если они реализуют RAII через метод `destroy`).

### Ключевое слово `delete`
Вызывает метод `destroy` у объекта (если есть), а затем освобождает память (или помечает как свободную). Используется для явного освобождения ресурсов.
```bpm
delete my_list; // Вызовет my_list.destroy(), затем memfree(my_list)
```

---

## 10. Препроцессор

*   `#define NAME val`: Текстовая замена (макрос). Поддерживает многострочные макросы через `$`.
*   `include "file"`: Вставка содержимого файла.
*   `static_assert(cond, msg)`: Проверка времени компиляции.
*   `__oninit { ... }`: Блок кода, выполняемый до `main` (используется для инициализации глобальных таблиц типов).
*   `__FILE__`, `__LINE__`, `__COL__`: Информация о текущем местоположении в исходном коде.

---

## 11. Низкоуровневые возможности

Встроенные функции (Intrinsics) для прямой работы с памятью и типами:

*   `asm "instruction"`: Вставка ассемблерного кода.
*   `cast(Type, expr)`: Реинтерпретация битов (аналог `reinterpret_cast` в C++).
*   `sizeof(Type)`: Размер типа (всегда 4 байта для переменных, но для `struct` возвращает размер выделяемого блока в куче).
*   `typeid(Type)`: Возвращает уникальный `int` (ID типа) для RTTI.
*   **Доступ к памяти:**
    *   `rd8(ptr)`, `rd16(ptr)`, `rd32(ptr)`: Чтение значения по адресу.
    *   `store8(ptr, val)`, `store16`, `store32`: Запись значения по адресу.

---

## 12. Пример работы со строками и памятью

```bpm
include "std"
include "std_string"

proc main() -> int {
    // Выделение памяти под строку (GC)
    let s = string::new("Hello");
    
    // Конкатенация (выделяет новый буфер)
    s += ", World!";
    
    // Вывод (использует интерфейс __StdPrintable)
    std::print(s); 
    
    // Прямой доступ к памяти (unsafe)
    let raw_ptr = s.m_data;
    let first_char = rd8(raw_ptr); // 'H'
    
    return 0;
}
```