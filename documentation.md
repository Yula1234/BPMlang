Это масштабная задача, и я готов её выполнить. Я проанализировал исходный код компилятора (лексер, парсер, генератор, рантайм) и реализацию стандартной библиотеки.

Ниже представлено **Полное руководство по языку программирования BPM**.

---

# The BPM Programming Language Reference Manual

**Версия документации:** 1.0
**Архитектура:** x86 (32-bit)
**Платформа:** Windows

---

## Оглавление

1.  [Введение](#1-введение)
2.  [Лексическая структура](#2-лексическая-структура)
3.  [Система типов](#3-система-типов)
4.  [Переменные и Константы](#4-переменные-и-константы)
5.  [Функции (Процедуры)](#5-функции-процедуры)
6.  [Управляющие конструкции](#6-управляющие-конструкции)
7.  [Объектно-Ориентированное Программирование](#7-объектно-ориентированное-программирование)
8.  [Шаблоны (Generics)](#8-шаблоны-generics)
9.  [Пространства имен](#9-пространства-имен)
10. [Управление памятью](#10-управление-памятью)
11. [Обработка исключений](#11-обработка-исключений)
12. [Препроцессор и Метапрограммирование](#12-препроцессор-и-метапрограммирование)
13. [Взаимодействие с низким уровнем (ASM/C)](#13-взаимодействие-с-низким-уровнем-asmc)
14. [Стандартная библиотека (Обзор)](#14-стандартная-библиотека-обзор)

---

## 1. Введение

BPM — это компилируемый, статически типизированный язык системного программирования. Он сочетает низкоуровневый контроль над памятью и процессором (как в C/Asm) с высокоуровневыми абстракциями (классы, шаблоны, исключения). Компилятор генерирует код на языке ассемблера NASM.

Ключевые особенности:
*   Отсутствие встроенного "тяжелого" рантайма (за исключением компактного сборщика мусора и обработчика исключений).
*   Мощная система перегрузки операторов.
*   Поддержка процедурного и объектного стилей.

---

## 2. Лексическая структура

### Идентификаторы
Идентификаторы могут содержать латинские буквы, цифры и символ подчеркивания `_`. Не могут начинаться с цифры.

### Комментарии
*   **Однострочные:** `//` — до конца строки.
*   **Многострочные:** `/* ... */` — блочные комментарии.

### Литералы
*   **Целые числа:** `123`, `-50`.
*   **Строки:** `"Hello"`. Поддерживают escape-последовательности (`\n`, `\"`, `\\`). Хранятся как нуль-терминированные C-строки.
*   **Символы:** `'a'`, `'\n'`. Представляют собой код символа (тип `int`).

---

## 3. Система типов

BPM является строго типизированным языком.

### Базовые типы

| Тип | Размер | Описание |
| :--- | :--- | :--- |
| `int` | 4 байта | Знаковое целое число (32-bit). Основной числовой тип. |
| `char` | 1 байт | Символ / байт. |
| `ptr` | 4 байта | Нетипизированный указатель (`void*`). |
| `void` | 0 байт | Пустой тип (используется только как возвращаемое значение). |
| `any` | 4 байта | Тип, совместимый с любым 4-байтным значением (для низкоуровневых хаков). |

### Производные типы
*   **Указатель (`*`):** `int*`, `char*`. Хранит адрес памяти.
*   **Ссылка (`&`):** `int&`. Используется для передачи аргументов по ссылке.
*   **Rvalue-ссылка (`&&`):** `string&&`. Используется для реализации семантики перемещения (move semantics).
*   **Указатель на процедуру:** `ProcPtr<RetType>`.

### Приведение типов
Используется оператор `cast(TargetType, Expression)`.
```rust
let p: ptr = ...;
let i: int = cast(int, p);
```
Также существует `cast_to(Expr, Expr)` для специфичных случаев.

---

## 4. Переменные и Константы

### Переменные (`let`)
Синтаксис: `let name: type = value;`
Тип может быть опущен, если он выводим из выражения.

```rust
let x: int = 10;
let y = 20;       // Тип int выведен автоматически
let z: ptr;       // Объявление без инициализации (значение не определено)
```

### Константы (`const`)
Константы вычисляются на этапе компиляции.
```rust
const BUFFER_SIZE = 1024;
const PI = 3;
```

### Глобальные переменные
Переменные, объявленные вне процедур, попадают в секцию `.bss` или `.data`.

---

## 5. Функции (Процедуры)

Объявляются ключевым словом `proc`.

### Синтаксис
```rust
proc name(arg1: type, arg2: type) -> ReturnType {
    // Тело
    return value;
}
```
Если `-> ReturnType` опущен, процедура возвращает `void`.
Также поддерживается сокращенный синтаксис для однострочных функций:
```rust
proc square(x: int) -> int = return x * x;
```

### Атрибуты процедур
Атрибуты указываются в квадратных скобках после сигнатуры:
*   `[nostdargs]`: Отключает копирование аргументов из стека в локальные переменные. Используется для ручного разбора стека.
*   `[noprolog]`: Отключает генерацию пролога (`push ebp`...) и эпилога. Полезно для `naked` функций.
*   `[nosizedargs]`: Разрешает вызов с произвольным количеством аргументов (вариативные функции).

### Перегрузка
Процедуры могут быть перегружены по типам аргументов и их количеству.

---

## 6. Управляющие конструкции

### Условное ветвление
```rust
if (condition) {
    // ...
} elif (other_condition) {
    // ...
} else {
    // ...
}
```

### Цикл `while`
```rust
while (condition) {
    if (should_stop) {
        break; // Прерывание цикла
    }
    // ...
}
```
Для циклов `for` используется макрос `foreach_range` из стандартной библиотеки.

### Exit
`exit(code)` — немедленное завершение программы через системный вызов `ExitProcess`.

---

## 7. Объектно-Ориентированное Программирование

### Структуры (`struct`)
Описывают раскладку данных в памяти.
```rust
struct Vector2 {
    x: int,
    y: int
}
```

### Методы (`impl`)
Методы определяются отдельно от данных.
```rust
impl Vector2 {
    // Конструктор (статический метод)
    proc new(x: int, y: int) -> Vector2 {
        // Создание объекта происходит автоматически при вызове имени структуры
        return Vector2(x, y);
    }

    // Метод экземпляра
    proc length_sq(self: ptr) -> int {
        // self - это указатель на структуру (this)
        return (self.x * self.x) + (self.y * self.y);
    }
}
```

### Синтаксис вызова методов
BPM поддерживает уникальный синтаксис вызова через тильду `~`:
```rust
let v = Vector2(10, 20);
let len = v~length_sq(); // Эквивалентно Vector2::length_sq(&v)
```
Также поддерживается классический синтаксис через точку `.` (если генератор находит метод): `v.length_sq()`.

### Перегрузка операторов
Операторы перегружаются путем объявления методов с зарезервированными именами в блоке `impl`.

| Оператор | Имя метода | Пример |
| :--- | :--- | :--- |
| `+` | `m_add` | `obj1 + obj2` |
| `-` | `m_sub` | `obj1 - obj2` |
| `*` | `m_mul` | `obj1 * obj2` |
| `/` | `m_div` | `obj1 / obj2` |
| `%` | `m_mod` | `obj1 % obj2` |
| `==` | `m_equal` | `obj1 == obj2` |
| `!=` | `m_not_equal` | `obj1 != obj2` |
| `<` | `m_less` | `obj1 < obj2` |
| `>` | `m_above` | `obj1 > obj2` |
| `<<` | `m_shl` | `obj1 << num` |
| `>>` | `m_shr` | `obj1 >> num` |
| `=` | `m_assign` | `obj1 = obj2` |
| `+=` | `m_inc` | `obj1 += val` |
| `-=` | `m_dec` | `obj1 -= val` |
| `*` (deref) | `m_deref` | `*obj` |
| `~` (call) | `m_call` | (зарезервировано) |

Пример:
```rust
impl Vector2 {
    proc m_add(self: ptr, other: ptr) -> Vector2 {
        return Vector2(self.x + other.x, self.y + other.y);
    }
}
```

---

## 8. Шаблоны (Generics)

BPM поддерживает параметрический полиморфизм. Шаблоны инстанцируются (мономорфизируются) во время компиляции.

### Шаблонные структуры
```rust
struct Box<T> {
    value: T
}
```

### Шаблонные процедуры
```rust
proc unbox<T>(b: Box<T>) -> T {
    return b.value;
}
```
Вызов: `unbox<int>(my_box)`. Часто типы выводятся автоматически: `unbox(my_box)`.

---

## 9. Пространства имен

Ключевое слово `namespace` используется для группировки кода и добавления статических методов к структурам.

```rust
namespace Math {
    proc abs(x: int) -> int { ... }
}

// Вызов
Math::abs(-5);
```

Блок `namespace StructName` часто используется как продолжение блока `impl`, позволяя добавлять методы к структуре.

---

## 10. Управление памятью

### Стек
Локальные переменные и аргументы хранятся на стеке.

### Куча (Heap)
BPM имеет встроенный менеджер памяти с элементами сборки мусора (Mark-and-Sweep), реализованный в `lib_core.c`.

*   `memalloc(size)`: Выделение сырой памяти.
*   `memfree(ptr)`: Освобождение памяти.

### New / Delete
Для работы с объектами используются высокоуровневые конструкции:
*   Создание: Вызов "конструктора" структуры (имени типа) `let s = String("txt");` или `std::alloc<T>(count)`.
*   Удаление: `delete expr;`.

Оператор `delete`:
1.  Проверяет наличие метода `destroy` у объекта.
2.  Если есть, вызывает `obj~destroy()`.
3.  Вызывает `memfree` для указателя.

### Buffers
Для создания статических массивов в стеке или `.bss`:
```rust
buffer buf(1024); // Выделяет 1024 байта
```

---

## 11. Обработка исключений

Реализована через механизм `setjmp`/`longjmp`.

### Выброс исключения (`raise`)
```rust
raise std::exception("Critical error");
```
Объект исключения должен быть структурой.

### Перехват (`try-catch`)
```rust
try {
    // Опасный код
} catch (e: std::exception) {
    // Обработка. 'e' содержит копию выброшенного объекта.
    puts(e~what());
}
```

---

## 12. Препроцессор и Метапрограммирование

### Макросы (`define`)
Синтаксис похож на C, но тело макроса заканчивается символом `$`.
```rust
#define MAX(a, b) ((a) > (b) ? (a) : (b))$
```

### Включение файлов (`include`)
```rust
include "std" // Ищет std.bpm в путях поиска
```

### Compile-Time проверки
*   `static_assert(expr, "msg")`: Ошибка компиляции, если `expr` ложно.
*   `ct_eval(expr)`: (Устарело) Принудительное вычисление выражения во время компиляции.
*   `ct_type(Type)`: Возвращает мета-тип для сравнения.
*   `is_same_t(T1, T2)`: Проверяет, являются ли типы одинаковыми.
*   `is_object_t(T)`: Проверяет, является ли тип структурой/классом.

### Интроспекция
*   `sizeof(Type)` или `sizeof(Expr)`: Размер в байтах.
*   `typeid(Type)`: Уникальный ID типа (int) во время выполнения.
*   `__LINE__`, `__FILE__`, `__COL__`.

### Блок инициализации (`oninit`)
Код внутри `oninit { ... }` выполняется до входа в `main`. Используется для инициализации глобальных переменных и библиотек.

---

## 13. Взаимодействие с низким уровнем (ASM/C)

### Inline Assembly
```rust
asm "mov eax, 0";
```

### Вызов C-функций (`cextern`)
```rust
cextern "printf"; // Импорт имени из libc
proc printf(fmt: char*) -> void [nosizedargs]; // Объявление сигнатуры
```

### Низкоуровневый доступ к памяти
Интринсики для чтения/записи по произвольным адресам:
*   `store8(ptr, val)`, `store16`, `store32`: Запись значения.
*   `rd8(ptr)`, `rd16`, `rd32`: Чтение значения (возвращает `int`).

---

## 14. Стандартная библиотека (Обзор)

Основана на модулях, присланных в качестве примера.

### `core` и `std`
*   `print(val)`, `fprint(fd, val)`: Вывод на экран/файл.
*   `malloc`, `free`, `memcpy`, `memset`: Работа с памятью.
*   `swap<T>`, `move<T>`: Утилиты.

### `string`
*   Класс `string`: Динамическая строка. Управляет памятью.
*   Конкатенация `+`, `+=`.
*   `streq`, `strlen`, `strcpy`.

### `string_view`
*   Класс `string_view`: Легковесная обертка (ptr + length) без владения памятью.
*   Методы: `trim_left`, `find`, `cut`.

### `vector`
*   Класс `vector<T>`: Динамический массив.
*   Методы: `push`, `pop`, `get`, `insert`.
*   Автоматический вызов деструкторов элементов при уничтожении вектора.

### `hash_map`
*   Класс `hash_map<Key, Value>`: Хеш-таблица.
*   Методы: `insert`, `find`, `contains`.

### `fsys`
*   Класс `FILE`: Обертка над файловыми дескрипторами C.
*   Методы: `open`, `close`, `read_to_string`.

### `algorithm`
*   `find`, `find_if`, `copy_range`.

---

**Компилятор:** `bpm.exe`
**Пример сборки:**
```cmd
bpm main.bpm -o app.exe
```