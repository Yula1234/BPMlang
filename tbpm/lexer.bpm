const TOKEN_KIND_PROC   = iota;
const TOKEN_KIND_ID     = iota;
const TOKEN_KIND_OPAREN = iota;
const TOKEN_KIND_CPAREN = iota;
const TOKEN_KIND_OCURLY = iota;
const TOKEN_KIND_CCURLY = iota;
const TOKEN_KIND_EOF    = reset;

proc tok_to_string(int kind) -> string {
    if(kind == TOKEN_KIND_PROC) {
        return string::new("`proc`");
    }
    elif(kind == TOKEN_KIND_ID) {
        return string::new("`identifier`");
    }
    elif(kind == TOKEN_KIND_OPAREN) {
        return string::new("`(`");
    }
    elif(kind == TOKEN_KIND_CPAREN) {
        return string::new("`)`");
    }
    elif(kind == TOKEN_KIND_OCURLY) {
        return string::new("`{`");
    }
    elif(kind == TOKEN_KIND_CCURLY) {
        return string::new("`}`");
    }
    elif(kind == TOKEN_KIND_EOF) {
        return string::new("<eof>");
    }
    assert(false, "unreachable");
}

struct Token {
    kind:  int,
    line:  int,
    col:   int,
    file:  string,
    value: char*
}

impl Token {
	proc kind_to_str(Token self) -> char* {
		if (self.kind == TOKEN_KIND_PROC) {
			return "proc";
		}
		elif (self.kind == TOKEN_KIND_ID) {
			return "id";
		}
		elif (self.kind == TOKEN_KIND_OPAREN) {
			return "(";
		}
		elif (self.kind == TOKEN_KIND_CPAREN) {
			return ")";
		}
		elif (self.kind == TOKEN_KIND_OCURLY) {
			return "{";
		}
		elif (self.kind == TOKEN_KIND_CCURLY) {
			return "}";
		}
		assert(false, "unreachable");
	}
	proc m_fprint(Token self, int fd) {
		std::fprint(fd, "Token(kind=");
		std::fprint(fd, self.kind_to_str());
        std::fprint(fd, ", line=");
        std::fprint(fd, self.line);
        std::fprint(fd, ", col=");
        std::fprint(fd, self.col);
        std::fprint(fd, ", file=");
        std::fprint(fd, self.file);
		std::fprint(fd, ", value=");
		std::fprint(fd, self.value);
		std::fprint(fd, ")");
	}
}

struct Lexer {
    m_src:  string,
    m_pos:  int,
    m_col: int,
    m_line: int,
    m_filename: string
}

proc is_alpha(int c) -> int {
    let lower = ((c > 'a') || (c == 'a')) && ((c < 'z') || (c == 'z'));
    let upper = ((c > 'A') || (c == 'A')) && ((c < 'Z') || (c == 'Z'));
    return lower || upper || (c == '_');
}

proc is_digit(int c) -> int {
    return ((c > '0') || (c == '0')) && ((c < '9') || (c == '9'));
}

proc is_alnum(int c) -> int {
    return is_alpha(c) || is_digit(c);
}

impl Lexer {

    proc new(string src, string filename) -> Lexer {
        return Lexer(src, 0, 1, 1, filename);
    }

    proc eof(Lexer self) -> int {
	    return not(self.m_pos < self.m_src.m_size);
	}

    proc current_char(Lexer self) -> int {
        if (self.eof()) return 0;
        return string::at(self.m_src, self.m_pos);
    }

    proc advance(Lexer self) -> void {
        if (not(self.eof())) {
            self.m_pos += 1;
            self.m_col += 1;
        }
    }

    proc skip_spaces(Lexer self) -> void {
        while (not(self.eof())) {
            let c = self.current_char();
            if ((c == ' ') || (c == '\t')) {
                self.advance();
            } else {
                break;
            }
        }
    }

    proc read_ident(Lexer self) -> Token {
        let start = self.m_pos;
        while (not(self.eof()) && is_alnum(self.current_char())) {
            self.advance();
        }

        let length = self.m_pos - start;

        let buf = string::new("");
        buf.extend(length + 1);
        let i = 0;
        while (i < length) {
            store8(buf.m_data + i, string::at(self.m_src, start + i));
            i += 1;
        }
        store8(buf.m_data + length, 0);

        if (string::m_equal(buf, "proc")) {
            return Token(TOKEN_KIND_PROC, self.m_line, self.m_col - length, self.m_filename, "");
        }

        return Token(TOKEN_KIND_ID, self.m_line, self.m_col - length, self.m_filename, buf.m_data);
    }

    proc next_token(Lexer self) -> Token {
        self.skip_spaces();
        if (self.eof()) {
            return Token(TOKEN_KIND_EOF, self.m_line, self.m_col - 1, self.m_filename, "");
        }

        let c = self.current_char();

        if (c == '\n') {
            self.m_line += 1;
            self.m_col = 1;
            self.advance();
            return self.next_token();
        }
        if (c == '(') {
            let start = self.m_pos;
            self.advance();
            return Token(TOKEN_KIND_OPAREN, self.m_line, self.m_col - 1, self.m_filename, "");
        }
        if (c == ')') {
            let start = self.m_pos;
            self.advance();
            return Token(TOKEN_KIND_CPAREN, self.m_line, self.m_col - 1, self.m_filename, "");
        }
        if (c == '{') {
            let start = self.m_pos;
            self.advance();
            return Token(TOKEN_KIND_OCURLY, self.m_line, self.m_col - 1, self.m_filename, "");
        }
        if (c == '}') {
            let start = self.m_pos;
            self.advance();
            return Token(TOKEN_KIND_CCURLY, self.m_line, self.m_col - 1, self.m_filename, "");
        }

        if (is_alpha(c)) {
            return self.read_ident();
        }

        raise std::exception("unexpected character");
    }
    proc lex(Lexer self) -> vector<Token> {
    	let res = vector::new<Token>();
    	while (not(self.eof())) {
        	let tok = self.next_token();
        	if (tok.kind == TOKEN_KIND_EOF) break; // EOF
        	res.push(tok);
    	}
    	return res;
    }
}