enum TOKEN_KIND {
    PROC,    
    ID,      
    OPAREN,  
    CPAREN,  
    OCURLY,  
    CCURLY,  
    LET,     
    EQ,      
    INT_LIT, 
    SEMI,
    PLUS,
    EOF,     
    COUNT,
}

struct Optional<T> {
    m_value: ptr,
    m_has_value: int
}

impl Optional<T> [new] {
    proc new<T>() -> Optional<T> = return Optional<T>(null(), 0);
    proc new<T>(T value) -> Optional<T> = return Optional<T>(cast(ptr, value), 1);
    proc has_value(Optional<T> self) -> int = return self.m_has_value;
    proc value(Optional<T> self) -> T {
        if(not(self.m_has_value)) {
            raise std::exception("null optional value access");
        }
        return cast(T, self.m_value);
    }
    proc m_assign(Optional<T> self, Optional<T> other) {
        self.m_value = other.m_value;
        self.m_has_value = other.m_has_value;
    }
}

proc tok_to_string(int kind) -> string {
    if(kind == TOKEN_KIND::PROC) {
        return string::new("`proc`");
    }
    elif(kind == TOKEN_KIND::ID) {
        return string::new("`identifier`");
    }
    elif(kind == TOKEN_KIND::OPAREN) {
        return string::new("`(`");
    }
    elif(kind == TOKEN_KIND::CPAREN) {
        return string::new("`)`");
    }
    elif(kind == TOKEN_KIND::OCURLY) {
        return string::new("`{`");
    }
    elif(kind == TOKEN_KIND::CCURLY) {
        return string::new("`}`");
    }
    elif(kind == TOKEN_KIND::LET) {
        return string::new("`let`");
    }
    elif(kind == TOKEN_KIND::EQ) {
        return string::new("`=`");
    }
    elif(kind == TOKEN_KIND::INT_LIT) {
        return string::new("`int literal`");
    }
    elif(kind == TOKEN_KIND::SEMI) {
        return string::new("`;`");
    }
    elif(kind == TOKEN_KIND::EOF) {
        return string::new("<eof>");
    }
    elif(kind == TOKEN_KIND::PLUS) {
        return string::new("<eof>");
    }
    assert(false, "unreachable");
}

struct Token {
    kind:  int,
    line:  int,
    col:   int,
    file:  string,
    value: char*
}

impl Token {
    proc make_fake() -> Token = return Token(TOKEN_KIND::EOF, 0, 0, string::new(""), "");
	proc kind_to_str(Token self) -> string {
		return tok_to_string(self.kind);
	}
	proc m_fprint(Token self, int fd) {
		std::fprint(fd, "Token(kind=");
		std::fprint(fd, self.kind_to_str());
        std::fprint(fd, ", line=");
        std::fprint(fd, self.line);
        std::fprint(fd, ", col=");
        std::fprint(fd, self.col);
        std::fprint(fd, ", file=");
        std::fprint(fd, self.file);
		std::fprint(fd, ", value=");
		std::fprint(fd, self.value);
		std::fprint(fd, ")");
	}
    proc m_assign(Token self, Token other) {
        self.kind = other.kind;
        self.line = other.line;
        self.col = other.col;
        self.file = other.file.clone();
        self.value = other.value;
    }
}

proc get_bin_prec(int tok_kind) -> Optional<int> {
    if(tok_kind == TOKEN_KIND::PLUS) {
        return Optional::new(5);
    }
    return Optional::new<int>();
}

struct Lexer {
    m_src:  string,
    m_pos:  int,
    m_col: int,
    m_line: int,
    m_filename: string
}

proc is_alpha(int c) -> int {
    let lower = ((c > 'a') || (c == 'a')) && ((c < 'z') || (c == 'z'));
    let upper = ((c > 'A') || (c == 'A')) && ((c < 'Z') || (c == 'Z'));
    return lower || upper || (c == '_');
}

proc is_digit(int c) -> int {
    return ((c > '0') || (c == '0')) && ((c < '9') || (c == '9'));
}

proc is_alnum(int c) -> int {
    return is_alpha(c) || is_digit(c);
}

impl Lexer {

    proc new(string src, string filename) -> Lexer {
        return Lexer(src, 0, 1, 1, filename.clone());
    }

    proc eof(Lexer self) -> int {
	    return not(self.m_pos < self.m_src.m_size);
	}

    proc current_char(Lexer self) -> int {
        if (self.eof()) return 0;
        return string::at(self.m_src, self.m_pos);
    }

    proc advance(Lexer self) -> void {
        if (not(self.eof())) {
            self.m_pos += 1;
            self.m_col += 1;
        }
    }

    proc skip_spaces(Lexer self) -> void {
        while (not(self.eof())) {
            let c = self.current_char();
            if ((c == ' ') || (c == '\t')) {
                self.advance();
            } else {
                break;
            }
        }
    }

    proc read_ident(Lexer self) -> Token {
        let start = self.m_pos;
        while (not(self.eof()) && is_alnum(self.current_char())) {
            self.advance();
        }

        let length = self.m_pos - start;

        let buf = string::new("");
        buf.extend(length + 1);
        let i = 0;
        while (i < length) {
            store8(buf.m_data + i, string::at(self.m_src, start + i));
            i += 1;
        }
        store8(buf.m_data + length, 0);

        if (string::m_equal(buf, "proc")) {
            return Token(TOKEN_KIND::PROC, self.m_line, self.m_col - length, self.m_filename.clone(), "");
        }
        elif (string::m_equal(buf, "let")) {
            return Token(TOKEN_KIND::LET, self.m_line, self.m_col - length, self.m_filename.clone(), "");
        }

        return Token(TOKEN_KIND::ID, self.m_line, self.m_col - length, self.m_filename.clone(), buf.m_data);
    }

    proc next_token(Lexer self) -> Token {
        self.skip_spaces();
        if (self.eof()) {
            return Token(TOKEN_KIND::EOF, self.m_line, self.m_col - 1, self.m_filename.clone(), "");
        }

        let c = self.current_char();

        if (c == '\n') {
            self.m_line += 1;
            self.m_col = 1;
            self.advance();
            return self.next_token();
        }
        if (c == '=') {
            self.advance();
            return Token(TOKEN_KIND::EQ, self.m_line, self.m_col - 1, self.m_filename.clone(), "");
        }
        if (c == '(') {
            self.advance();
            return Token(TOKEN_KIND::OPAREN, self.m_line, self.m_col - 1, self.m_filename.clone(), "");
        }
        if (c == ')') {
            self.advance();
            return Token(TOKEN_KIND::CPAREN, self.m_line, self.m_col - 1, self.m_filename.clone(), "");
        }
        if (c == '{') {
            self.advance();
            return Token(TOKEN_KIND::OCURLY, self.m_line, self.m_col - 1, self.m_filename.clone(), "");
        }
        if (c == '}') {
            self.advance();
            return Token(TOKEN_KIND::CCURLY, self.m_line, self.m_col - 1, self.m_filename.clone(), "");
        }
        if (c == ';') {
            self.advance();
            return Token(TOKEN_KIND::SEMI, self.m_line, self.m_col - 1, self.m_filename.clone(), "");
        }
        if (c == '+') {
            self.advance();
            return Token(TOKEN_KIND::PLUS, self.m_line, self.m_col - 1, self.m_filename.clone(), "");
        }
        if (is_digit(c)) {
            let buf = string::new("");
            buf.push_back(c);
            self.advance();
            while(self.current_char() != 0 && is_digit(self.current_char())) {
                buf.push_back(self.current_char());
                self.advance();
            }
            return Token(TOKEN_KIND::INT_LIT, self.m_line, self.m_col - buf.size(), self.m_filename.clone(), buf.m_data);
        }

        if (is_alpha(c)) {
            return self.read_ident();
        }

        raise std::exception("unexpected character");
    }
    proc lex(Lexer self) -> vector<Token> {
    	let res = vector::new<Token>();
    	while (not(self.eof())) {
        	let tok = self.next_token();
        	if (tok.kind == TOKEN_KIND::EOF) break; // EOF
        	res.push(tok);
    	}
    	return res;
    }
}