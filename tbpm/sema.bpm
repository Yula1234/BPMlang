enum SYMBOL_KIND {
	VAR, PROC
}

struct SymbolVar {
	offset: int,
	is_global: int,
	type: DataType
}

struct SymbolProc {
	rettype: DataType,
	params: vector<pair<string, DataType>>
}

struct SymbolInfo {
    name: string,
    kind: int,
    var: ptr
}

impl SymbolInfo {
	proc m_assign(SymbolInfo self, SymbolInfo other) {
		self.name = other.name.clone();
		self.kind = other.kind;
		self.var = other.var;
	}
}

struct Scope {
    symbols: map<string, SymbolInfo>,
}

struct SymbolTable {
    scopes: deque<Scope>
}

impl SymbolTable {
	proc new() -> SymbolTable {
		return SymbolTable(deque::new<Scope>());
	}
    proc enter_scope(SymbolTable self) {
    	self.scopes.push_front(Scope(map::new<string, SymbolInfo>()));
    }
    proc exit_scope(SymbolTable self) {
    	assert(not(self.scopes.empty()), "unreachable");
    	let _ = self.scopes.pop_front();
    }
    proc put(SymbolTable self, string name, SymbolInfo info) {
    	self.scopes.front().symbols.put(name, info);
    }
    proc lookup(SymbolTable self, string name) -> Optional<SymbolInfo> {
    	assert(not(self.scopes.empty()), "unreachable");
        foreach(let current : self.scopes) {
            if (current.symbols.has(name)) {
                let info = current.symbols.get(name);
                return Optional::new(info);
            }
        }
        
        return Optional::new<SymbolInfo>();
    }
}

struct SemanticContext {
	prog: NodeProg,
	symbol_table: SymbolTable,
	prs: Parser,
	cur_proc: ptr
}

impl SemanticContext {
	proc new(NodeProg prog, Parser prs) -> SemanticContext {
		return SemanticContext(prog, SymbolTable::new(), prs, null());
	}

	proc register_variable(SemanticContext self, string name, DataType type, int is_global) -> SymbolInfo {
		assert(self.cur_proc != null(), "unreachable");
		let soffs = cast(NodeStmtProc, self.cur_proc).stack_allign + 4;
		let sym = SymbolInfo(name, SYMBOL_KIND::VAR, 
			cast(ptr, SymbolVar(
				soffs, is_global, type
			))
		);
		self.symbol_table.put(name, sym);
		cast(NodeStmtProc, self.cur_proc).stack_allign += 4;
		return sym;
	}

	proc analyze_expr(SemanticContext self, NodeExpr expr) -> DataType;


	proc analyze_term(SemanticContext self, NodeTerm term) -> DataType {
		if(term.kind == NODE_TERM_KIND::INT_LIT) {
			return DataType::new_primitive(PRIM_KIND::INT);
		}
		if(term.kind == NODE_TERM_KIND::IDENT) {
			let as_ident = cast(NodeTermIdent, term.var);
			let sym = self.symbol_table.lookup(as_ident.name);
			if(not(sym.has_value())) {
				self.prs.DiagnosticMessage(as_ident.def, "error", string::new("unkown symbol `") + as_ident.name + "`", 0);
				exit(EXIT_FAILURE);
			}
			as_ident.resolved_symbol = cast(ptr, sym.value());
			if(sym.value().kind == SYMBOL_KIND::VAR) {
				return cast(SymbolVar, sym.value().var).type;
			} else {
				self.prs.DiagnosticMessage(as_ident.def, "error", string::new("can't use non-variable symbol in expression `") + as_ident.name + "`", 0);
				exit(EXIT_FAILURE);
			}
		}
		if (term.kind == NODE_TERM_KIND::CALL) {
			let call = cast(NodeTermCall, term.var);
			let sym_opt = self.symbol_table.lookup(call.name);
				    
			if (not(sym_opt.has_value())) {
			    self.prs.DiagnosticMessage(call.def, "error", string::new("unknown procedure `") + call.name + "`", 0);
			    exit(EXIT_FAILURE);
			}
				    
			let sym = sym_opt.value();
			if (not(sym.kind == SYMBOL_KIND::PROC)) {
			    self.prs.DiagnosticMessage(call.def, "error", string::new("symbol '") + call.name + "' is not a procedure", 0);
			    exit(EXIT_FAILURE);
			}

			call.resolved_symbol = cast(ptr, sym);

			let sym_proc = cast(SymbolProc, sym.var);

			foreach(let arg : call.args) {
				self.analyze_expr(arg);
			}

			if(call.args.size() != sym_proc.params.size()) {
				buffer __err(256);
				sprintf(&__err, "precedure `%s` excepts %d argument(s) but got %d", call.name.m_data, sym_proc.params.size(), call.args.size());
				self.prs.DiagnosticMessage(call.def, "error", string::new(&__err), 0);
			    exit(EXIT_FAILURE);
			}
			for(let i = 0;i < call.args.size();i += 1) {
				let atype = self.analyze_expr(call.args[i]);
				if(not(atype.equals(sym_proc.params[i].second))) {
					buffer __err(256);
					sprintf(&__err, "precedure `%s` excepts type `%s` at %d argument but got `%s`", call.name.m_data, sym_proc.params[i].second.to_string().m_data, i, atype.to_string().m_data);
					self.prs.DiagnosticMessage(call.def, "error", string::new(&__err), 0);
			    	exit(EXIT_FAILURE);
				}
			}
				    
			return sym_proc.rettype; 
		}
		assert(false, "unreachable");
	}


	proc analyze_bin_expr(SemanticContext self, NodeBinExpr bin_expr) -> DataType {
		if(bin_expr.kind == NODE_BIN_EXPR_KIND::ADD) {
			let as_add = cast(NodeBinExprAdd, bin_expr.var);
			let type_lhs = self.analyze_expr(as_add.lhs);
			let type_rhs = self.analyze_expr(as_add.rhs);
			if(not(type_lhs.equals(type_rhs))) {
				self.prs.DiagnosticMessage(bin_expr.def, "error", string::new("+ type mismatch"), 0);
				exit(EXIT_FAILURE);
			}
			return type_lhs;
		}
		if(bin_expr.kind == NODE_BIN_EXPR_KIND::SUB) {
			let as_sub = cast(NodeBinExprSub, bin_expr.var);
			let type_lhs = self.analyze_expr(as_sub.lhs);
			let type_rhs = self.analyze_expr(as_sub.rhs);
			if(not(type_lhs.equals(type_rhs))) {
				self.prs.DiagnosticMessage(bin_expr.def, "error", string::new("- type mismatch"), 0);
				exit(EXIT_FAILURE);
			}
			return type_lhs;
		}
		if(bin_expr.kind == NODE_BIN_EXPR_KIND::DIV) {
			let as_div = cast(NodeBinExprDiv, bin_expr.var);
			let type_lhs = self.analyze_expr(as_div.lhs);
			let type_rhs = self.analyze_expr(as_div.rhs);
			if(not(type_lhs.equals(type_rhs))) {
				self.prs.DiagnosticMessage(bin_expr.def, "error", string::new("/ type mismatch"), 0);
				exit(EXIT_FAILURE);
			}
			return type_lhs;
		}
		if(bin_expr.kind == NODE_BIN_EXPR_KIND::MUL) {
			let as_mul = cast(NodeBinExprMul, bin_expr.var);
			let type_lhs = self.analyze_expr(as_mul.lhs);
			let type_rhs = self.analyze_expr(as_mul.rhs);
			if(not(type_lhs.equals(type_rhs))) {
				self.prs.DiagnosticMessage(bin_expr.def, "error", string::new("* type mismatch"), 0);
				exit(EXIT_FAILURE);
			}
			return type_lhs;
		}
		assert(false, "unreachable");
	}

	proc analyze_expr(SemanticContext self, NodeExpr expr) -> DataType {
		if(expr.cached_type != null()) {
			return cast(DataType, expr.cached_type);
		}
		if(expr.kind == NODE_EXPR_KIND::TERM) {
			let as_term = cast(NodeTerm, expr.var);
			let tp = self.analyze_term(as_term);
			expr.cached_type = cast(ptr, tp);
			return tp;
		}
		if(expr.kind == NODE_EXPR_KIND::BIN_EXPR) {
			let as_bin = cast(NodeBinExpr, expr.var);
			let tp = self.analyze_bin_expr(as_bin);
			expr.cached_type = cast(ptr, tp);
			return tp;
		}
		assert(false, "unreachable");
	}
	proc analyze_scope(SemanticContext self, NodeScope scope);

	proc analyze_stmt(SemanticContext self, NodeStmt stmt) {
		if(stmt.kind == NODE_STMT_KIND::PROC) {
			let as_proc = cast(NodeStmtProc, stmt.var);
			self.cur_proc = cast(ptr, as_proc);
			self.symbol_table.put(as_proc.name, SymbolInfo(
				as_proc.name,
				SYMBOL_KIND::PROC,
				cast(ptr, SymbolProc(
					as_proc.rettype,
					as_proc.params
				))
			));
			self.symbol_table.enter_scope();
			foreach(let pr : as_proc.params) {
				self.register_variable(pr.first, pr.second, false);
			}
			self.analyze_scope(as_proc.scope);
			self.symbol_table.exit_scope();
			self.cur_proc = null();
			return;
		}
		if(stmt.kind == NODE_STMT_KIND::LET) {
			let as_let = cast(NodeStmtLet, stmt.var);
			let _opt = as_let.type;
			let _opext = Optional::new<DataType>();
			if(self.cur_proc == null()) {
				self.prs.DiagnosticMessage(as_let.def, "error", string::new("can't define global variable yet"), 0);
				exit(EXIT_FAILURE);
			}
			if(as_let.expr.has_value()) {
				_opext = Optional::new(self.analyze_expr(as_let.expr.value()));
			}
			if(_opt.has_value() && _opext.has_value() && not(_opt.value().equals(_opext.value()))) {
				self.prs.DiagnosticMessage(as_let.def, "error", string::new("type mismatch"), 0);
				exit(EXIT_FAILURE);
			}
			let _final_tp = Optional::new<DataType>();
			if(_opt.has_value()) {
				_final_tp = _opt;
			}
			elif(_opext.has_value()) {
				_final_tp = _opext;
			}
			assert(_final_tp.has_value(), "unreachable");
			let sym = cast(SymbolVar, self.register_variable(as_let.name, _final_tp.value(), false).var);
			as_let.stack_loc = sym.offset;
			return;
		}
		if(stmt.kind == NODE_STMT_KIND::RETURN) {
			let as_return = cast(NodeStmtReturn, stmt.var);
			if(self.cur_proc == null()) {
				self.prs.DiagnosticMessage(as_return.def, "error", string::new("return without procedure"), 0);
				exit(EXIT_FAILURE);
			}
			let cproc = cast(NodeStmtProc, self.cur_proc);
			if(not(cproc.rettype.equals(DataType::new_primitive(PRIM_KIND::VOID))) && not(as_return.expr.has_value())) {
				self.prs.DiagnosticMessage(as_return.def, "error", string::new("return without value from non-void procedure"), 0);
				exit(EXIT_FAILURE);
			}
			elif(cproc.rettype.equals(DataType::new_primitive(PRIM_KIND::VOID)) && as_return.expr.has_value()) {
				self.prs.DiagnosticMessage(as_return.def, "error", string::new("return with value from void procedure"), 0);
				exit(EXIT_FAILURE);
			}
			if(as_return.expr.has_value()) {
				let rt = self.analyze_expr(as_return.expr.value());
				if(not(cproc.rettype.equals(rt))) {
					self.prs.DiagnosticMessage(as_return.def, "error", string::new("type mismatch at return"), 0);
					exit(EXIT_FAILURE);
				}
			}
			as_return.loc = "__";
			as_return.loc += cproc.name + "@ret";
			return;
		}
		if(stmt.kind == NODE_STMT_KIND::EXPR) {
			let as_expr = cast(NodeStmtExpr, stmt.var);
			self.analyze_expr(as_expr.expr);
			return;
		}
		assert(false, "unreachable");
	}

	proc analyze_scope(SemanticContext self, NodeScope scope) {
		foreach(let st : scope.stmts) {
			self.analyze_stmt(st);
		}
	}

	proc analyze(SemanticContext self) {
		self.symbol_table.enter_scope();
		foreach(let stmt : self.prog.stmts) {
			self.analyze_stmt(stmt);
		}
		// self.symbol_table.exit_scope(); global scope can't be deleted
	}
}