proc push_ast ast:ptr index:ptr element:ptr -> void {
	store32(ast + (rd32(index) * 4), element);
	store32(index, rd32(index) + 1);
}

struct parser {
	tokens:ptr,
	index:int
}

proc new_parser tokens:ptr -> parser {
	return parser(tokens, 0);
}

proc parser_peek prs:parser -> Token {
	if(rd32(prs.tokens + (prs.index * 4)) == 0) {
		return cast(Token, 0);
	}
	return cast(Token, rd32(prs.tokens + (prs.index * 4)));
}

proc parser_peek_at prs:parser offs:int -> Token {
	if(rd32(prs.tokens + ((prs.index + offs) * 4)) == 0) {
		return cast(Token, 0);
	}
	return cast(Token, rd32(prs.tokens + ((prs.index + offs) * 4)));
}

proc parser_peek_prev prs:parser -> Token {
	if(rd32(prs.tokens + ((prs.index - 1) * 4)) == 0) {
		return cast(Token, 0);
	}
	return cast(Token, rd32(prs.tokens + ((prs.index - 1) * 4)));
}

proc parser_consume prs:parser -> Token {
	let tok = parser_peek(prs);
	prs.index = prs.index + 1;
	return tok;
}

proc parser_consume_err prs:parser _type:int -> Token;

const Data_typeInt  iota;
const Data_typeVoid iota;
const Data_typePtr  iota;
const Data_typesCount reset;

proc dt_to_string dt:int -> ptr {
	if(dt == Data_typeInt) {
		return "`int`";
	}
	elif(dt == Data_typeVoid) {
		return "`void`";
	}
	elif(dt == Data_typePtr) {
		return "`ptr`";
	}
	puts("`dt_to_string` unkown dt\n");
	exit(1);
}

proc is__type_token tok_type:int -> int {
	if(tok_type == Token_typeVoid) {
		return true;
	}
	if(tok_type == Token_typeInt) {
		return true;
	}
	return false;
}

proc token_to_dt tok_type:int -> int {
	if(tok_type == Token_typeVoid) {
		return Data_typeVoid;
	}
	if(tok_type == Token_typeInt) {
		return Data_typeInt;
	}
	puts("`token_to_dt` unkown tok_type\n");
	exit(1);
}

struct NodeExprAdd(__global_obj_alloc) {
	left:ptr,
	right:ptr,
	def:Token
}

struct NodeExprSub(__global_obj_alloc) {
	left:ptr,
	right:ptr,
	def:Token
}

struct NodeExprMul(__global_obj_alloc) {
	left:ptr,
	right:ptr,
	def:Token
}

struct NodeExprDiv(__global_obj_alloc) {
	left:ptr,
	right:ptr,
	def:Token
}

struct NodeExprIdent(__global_obj_alloc) {
	def:Token,
	ident:ptr
}

struct NodeExprCall(__global_obj_alloc) {
	def:Token,
	name:ptr,
	args:DynamicArray
}

struct NodeExpr(__global_obj_alloc) {
	kind:int,
	data:ptr
}

const NodeKindInt   iota;
const NodeKindPlus  iota;
const NodeKindMinus iota;
const NodeKindMul   iota;
const NodeKindDiv   iota;
const NodeKindIdent iota;
const NodeKindCall  iota;
const NodeKindsCount reset;

proc Error str:ptr file:ptr line:int col:int -> void {
	format_print("%s:%d:%d ERROR: %s\n", file, line, col, str);
	exit(1);
}

proc parser_parse_args prs:parser -> DynamicArray;

proc parser_parse_term prs:parser -> NodeExpr {
	if(parser_peek(prs)._type == Token_typeIntLiteral) {
		let number_tok = parser_consume(prs);
		let expr_int = NodeExpr(NodeKindInt, number_tok.value);
		return expr_int;
	}
	if((parser_peek(prs)._type == Token_typeIdent) && (parser_peek_at(prs, 1)._type == Token_typeOpenParen)) {
		let def = parser_consume(prs);
		parser_consume_err(prs, Token_typeOpenParen);
		let args: DynamicArray;
		if(parser_peek(prs)._type != Token_typeCloseParen) {
			args = parser_parse_args(prs);
		}
		else {
			args = cast(DynamicArray, 0);
		}
		parser_consume_err(prs, Token_typeCloseParen);
		let expr_call = NodeExprCall(def, def.value, args);
		let fexpr = NodeExpr(NodeKindCall, cast(ptr, expr_call));
		return fexpr;
	}
	if(parser_peek(prs)._type == Token_typeIdent) {
		let tok = parser_consume(prs);
		let expr_ident = NodeExprIdent(tok, tok.value);
		let fexpr = NodeExpr(NodeKindIdent, cast(ptr, expr_ident));
		return fexpr;
	}
	putu(parser_peek(prs)._type);
	puts("Parser error (parse_term)\n");
	exit(1);
}

const NULL_PREC 4294967295;

const PLUS_PREC iota;
const MUL_PREC 	iota;
const PRECS_COUNT reset;

proc is_bin_operator tok_type:int -> int;

proc bin_prec tok_type:int -> int {
	if(is_bin_operator(tok_type) != 1) {
		return NULL_PREC;
	}
	if(tok_type == Token_typePlus) {
		return PLUS_PREC;
	}
	elif(tok_type == Token_typeMinus) {
		return PLUS_PREC;
	}
	elif(tok_type == Token_typeStar) {
		return MUL_PREC;
	}
	elif(tok_type == Token_typeSlash) {
		return MUL_PREC;
	}
	return NULL_PREC;
}

proc is_bin_operator tok_type:int -> int {
	if(tok_type == Token_typePlus) {
		return true;
	}
	elif(tok_type == Token_typeMinus) {
		return true;
	}
	elif(tok_type == Token_typeStar) {
		return true;
	}
	elif(tok_type == Token_typeSlash) {
		return true;
	}
	return false;
}

proc parser_parse_expr prs:parser min_prec:int -> NodeExpr;

proc parser_parse_args prs:parser -> DynamicArray {
	let args = new_dynarray(4);
	let i = 0;
	if(parser_peek(prs)._type == Token_typeCloseParen) {
		return args;
	}
	while(parser_peek(prs)._type != Token_typeCloseParen) {
		let _expr = parser_parse_expr(prs, 0);
		dynarray_push(args, _expr);
		if((parser_peek(prs)._type != Token_typeComma) && (parser_peek(prs)._type != Token_typeCloseParen)) {
			let ctok = parser_peek(prs);
			Error("excepted args", ctok.file_loc, ctok.line, ctok.col);
		}
		if(parser_peek(prs)._type == Token_typeComma) {
			parser_consume(prs);
		}
	}
	return args;
}

proc parser_parse_expr prs:parser min_prec:int -> NodeExpr {
	let term_lhs = parser_parse_term(prs);
	let expr_lhs = NodeExpr(term_lhs.kind, term_lhs.data);
	while(true) {
		let cur_tok = parser_peek(prs);
		let prec = NULL_PREC;
		if(cast(int, cur_tok) != 0) {
			prec = bin_prec(cur_tok._type);
			if(prec == NULL_PREC) {
				break;
			}
			if(prec < min_prec) {
				break;
			}
		}
		else {
			break;
		}
		let ctok = parser_consume(prs);
		let next_min_prec = min_prec + 1;
		let expr_rhs = parser_parse_expr(prs, next_min_prec);
		let expr = NodeExpr();
		let expr_lhs2 = NodeExpr();
		if(ctok._type == Token_typePlus) {
			expr_lhs2.data = expr_lhs.data;
			expr_lhs2.kind = expr_lhs.kind;
			let add = NodeExprAdd(cast(ptr, expr_lhs2), cast(ptr, expr_rhs), ctok);
			expr.kind = NodeKindPlus;
			expr.data = cast(ptr, add);
		}
		elif(ctok._type == Token_typeMinus) {
			expr_lhs2.data = expr_lhs.data;
			expr_lhs2.kind = expr_lhs.kind;
			let sub = NodeExprSub(cast(ptr, expr_lhs2), cast(ptr, expr_rhs), ctok);
			expr.kind = NodeKindMinus;
			expr.data = cast(ptr, sub);
		}
		elif(ctok._type == Token_typeStar) {
			expr_lhs2.data = expr_lhs.data;
			expr_lhs2.kind = expr_lhs.kind;
			let mul = NodeExprMul(cast(ptr, expr_lhs2), cast(ptr, expr_rhs), ctok);
			expr.kind = NodeKindMul;
			expr.data = cast(ptr, mul);
		}
		elif(ctok._type == Token_typeSlash) {
			expr_lhs2.data = expr_lhs.data;
			expr_lhs2.kind = expr_lhs.kind;
			let div = NodeExprDiv(cast(ptr, expr_lhs2), cast(ptr, expr_rhs), ctok);
			expr.kind = NodeKindDiv;
			expr.data = cast(ptr, div);
		}
		else { 
			Error("parser_parse_expr unreacheable", ctok.file_loc, ctok.line, ctok.col);
		}
		expr_lhs.data = expr.data;
		expr_lhs.kind = expr.kind;
	}
	return expr_lhs;
}

proc parser_consume_err prs:parser _type:int -> Token {
	let tok = parser_peek(prs);
	if(cast(int, tok) == 0) {
		let prev = parser_peek_prev(prs);
		format_print("%s:%d:%d ERROR: excepted %s, but got nothing\n", prev.file_loc, prev.line, prev.col, token_type2str(_type));
		exit(1);
	}
	elif(tok._type != _type) {
		format_print("%s:%d:%d ERROR: excepted %s, but got %s\n", tok.file_loc, tok.line, tok.col, token_type2str(_type), token_type2str(tok._type));
		exit(1);
	}
	parser_consume(prs);
	return tok;
}

struct NodeStmt(__global_obj_alloc) {
	kind:int,
	data:ptr
}

struct NodeStmtExit(__global_obj_alloc) {
	expr:ptr
}

struct NodeStmtPrint(__global_obj_alloc) {
	expr:ptr
}

struct NodeStmtLet(__global_obj_alloc) {
	name:ptr,
	expr:ptr,
	def:Token
}

struct NodeStmtBlock(__global_obj_alloc) {
	stmts:DynamicArray
}

struct NodeStmtCall(__global_obj_alloc) {
	def:Token,
	name:ptr,
	args:DynamicArray
}

const PredKindElse iota;
const PredKindElif iota;
const IfPredsCount reset;

struct IfPredElse(__global_obj_alloc) {
	block:NodeStmtBlock
}

struct IfPredElif(__global_obj_alloc) {
	block:NodeStmtBlock,
	condition:NodeExpr,
	pred:ptr
}

struct NodeIfPred(__global_obj_alloc) {
	kind:int,
	data:ptr
}

struct NodeStmtIf(__global_obj_alloc) {
	block:NodeStmtBlock,
	condition:NodeExpr,
	pred:ptr
}

struct ProcArg(__global_obj_alloc) {
	name:ptr,
	_type:int
}

struct NodeStmtProc(__global_obj_alloc) {
	block:NodeStmtBlock,
	name:ptr,
	_type:int,
	def:Token,
	args:DynamicArray
}

struct NodeStmtReturn(__global_obj_alloc) {
	def:Token,
	expr:NodeExpr
}

const StmtKindExit   iota;
const StmtKindPrint  iota;
const StmtKindLet    iota;
const StmtKindIf     iota;
const StmtKindProc   iota;
const StmtKindCall   iota;
const StmtKindReturn iota;
const StmtKindsCount reset;

proc parser_parse_stmt prs:parser -> int;

proc parser_parse_block prs:parser -> NodeStmtBlock {
	if(parser_peek(prs)._type != Token_typeOpenCurly) {
		let tok = parser_peek(prs);
		Error("excepted {", tok.file_loc, tok.line, tok.col);
	}
	parser_consume(prs);
	let block = NodeStmtBlock(new_dynarray(8));
	while(true) {
		let _stmt = parser_parse_stmt(prs);
		if(_stmt == 0) {
			break;
		}
		dynarray_push(block.stmts, _stmt);
	}
	parser_consume_err(prs, Token_typeCloseCurly);
	return block;
}

proc parse_if_pred prs:parser -> ptr {
	if(parser_peek(prs)._type == Token_typeElse) {
		parser_consume(prs);
		let else_block = parser_parse_block(prs);
		let else_pred = IfPredElse(else_block);
		return cast(ptr, NodeIfPred(PredKindElse, cast(ptr, else_pred)));
	}
	elif(parser_peek(prs)._type == Token_typeElif) {
		parser_consume(prs);
		parser_consume_err(prs, Token_typeOpenParen);
		let _condition = parser_parse_expr(prs, 0);
		parser_consume_err(prs, Token_typeCloseParen);
		let elif_block = parser_parse_block(prs);
		let elif_pred = IfPredElif(elif_block, _condition, cast(ptr, 0));
		if(cast(int, parser_peek(prs)) != 0) {
			let pd = parse_if_pred(prs);
			elif_pred.pred = pd;
		}
		return cast(ptr, NodeIfPred(PredKindElif, cast(ptr, elif_pred)));
	}
	return cast(ptr, 0);
}

proc put_arg arg:ProcArg -> void {
	format_print("ProcArg(%s, %s)\n", arg.name, dt_to_string(arg._type));
}

proc parser_parse_stmt prs:parser -> int {
	let def_tok: Token;
	if(parser_peek(prs)._type == Token_typeExit) {
		def_tok = parser_consume(prs);
		parser_consume_err(prs, Token_typeOpenParen);
		let expr_exit = cast(ptr, parser_parse_expr(prs, 0));
		let stmt_exit = NodeStmtExit(expr_exit);
		let stmt = NodeStmt(StmtKindExit, cast(ptr, stmt_exit));
		parser_consume_err(prs, Token_typeCloseParen);
		parser_consume_err(prs, Token_typeSemi);
		return cast(int, stmt);
	}
	elif(parser_peek(prs)._type == Token_typePrint) {
		def_tok = parser_consume(prs);
		parser_consume_err(prs, Token_typeOpenParen);
		let expr_print = cast(ptr, parser_parse_expr(prs, 0));
		let stmt_print = NodeStmtPrint(expr_print);
		let stmt = NodeStmt(StmtKindPrint, cast(ptr, stmt_print));
		parser_consume_err(prs, Token_typeCloseParen);
		parser_consume_err(prs, Token_typeSemi);
		return cast(int, stmt);
	}
	elif(parser_peek(prs)._type == Token_typeLet) {
		def_tok = parser_consume(prs);
		let ident_tok = parser_consume_err(prs, Token_typeIdent);
		parser_consume_err(prs, Token_typeEq);
		let expr_let = cast(ptr, parser_parse_expr(prs, 0));
		let stmt_let = NodeStmtLet(ident_tok.value, expr_let, def_tok);
		let stmt = NodeStmt(StmtKindLet, cast(ptr, stmt_let));
		parser_consume_err(prs, Token_typeSemi);
		return cast(int, stmt);
	}
	elif(parser_peek(prs)._type == Token_typeIf) {
		parser_consume(prs); // skip IF keyword
		parser_consume_err(prs, Token_typeOpenParen);
		let _condition = parser_parse_expr(prs, 0);
		parser_consume_err(prs, Token_typeCloseParen);
		let block = parser_parse_block(prs);
		let stmt_if = NodeStmtIf(block, _condition, cast(ptr, 0));
		if(cast(int, parser_peek(prs)) != 0) {
			stmt_if.pred = parse_if_pred(prs);
		}
		let stmt = NodeStmt(StmtKindIf, cast(ptr, stmt_if));
		return cast(int, stmt);
	}
	elif(parser_peek(prs)._type == Token_typeProc) {
		let def = parser_consume(prs);
		let name = parser_consume_err(prs, Token_typeIdent).value;
		let args = new_dynarray(4);
		if(parser_peek(prs)._type != Token_typeArrow) {
			while(parser_peek(prs)._type != Token_typeArrow) {
				let ntok = parser_consume_err(prs, Token_typeIdent);
				parser_consume_err(prs, Token_typeDoubleColon);
				let _typetok = parser_consume(prs);
				if(is__type_token(_typetok._type) != 1) {
					Error("excepted procedure return _type", _typetok.file_loc, _typetok.line, _typetok.col);
				}
				let arg = ProcArg(ntok.value, token_to_dt(_typetok._type));
				dynarray_push(args, arg);
			}
		}
		parser_consume_err(prs, Token_typeArrow);
		let t_type = parser_consume(prs);
		if(is__type_token(t_type._type) != 1) {
			Error("excepted procedure return _type", t_type.file_loc, t_type.line, t_type.col);
		}
		let block = parser_parse_block(prs);
		let proc_stmt = NodeStmtProc(block, name, token_to_dt(t_type._type), def, args);
		let stmt = NodeStmt(StmtKindProc, cast(ptr, proc_stmt));
		return cast(int, stmt);
	}
	elif((parser_peek(prs)._type == Token_typeIdent) && parser_peek_at(prs, 1)._type == Token_typeOpenParen) {
		let def = parser_consume(prs);
		parser_consume_err(prs, Token_typeOpenParen);
		let args: DynamicArray;
		if(parser_peek(prs)._type != Token_typeCloseParen) {
			args = parser_parse_args(prs);
		}
		else {
			args = cast(DynamicArray, 0);
		}
		parser_consume_err(prs, Token_typeCloseParen);
		parser_consume_err(prs, Token_typeSemi);
		let call_stmt = NodeStmtCall(def, def.value, args);
		let stmt = NodeStmt(StmtKindCall, cast(ptr, call_stmt));
		return cast(int, stmt);
	}
	elif(parser_peek(prs)._type == Token_typeReturn) {
		let def = parser_consume(prs);
		let _rexpr = parser_parse_expr(prs, 0);
		parser_consume_err(prs, Token_typeSemi);
		let ret_stmt = NodeStmtReturn(def, _rexpr);
		let stmt = NodeStmt(StmtKindReturn, cast(ptr, ret_stmt));
		return cast(int, stmt);
	}
	return 0;
}

proc parser_parse prs:parser ast:ptr -> void {
	let ast_level = 0;
	while(cast(int, parser_peek(prs)) != 0) {
		let stmt = parser_parse_stmt(prs);
		if(stmt == 0) {
			let tok = parser_peek(prs);
			Error("excepted statement", tok.file_loc, tok.line, tok.col);
		}
		push_ast(ast, &ast_level, cast(ptr, stmt));
	}
	store32(ast + (ast_level * 4), 0);
}