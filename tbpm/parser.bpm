

struct Parser {
	m_tokens: vector<Token>,
	m_index: int,
	m_preprocessor_stmt: int
}

proc token_to_dt(int kind) -> DataType {
	if(kind == TOKEN_KIND::INT_TYPE) {
		return DataType::new_primitive(PRIM_KIND::INT);
	}
	elif(kind == TOKEN_KIND::CHAR_TYPE) {
		return DataType::new_primitive(PRIM_KIND::CHAR);
	}
	elif(kind == TOKEN_KIND::VOID_TYPE) {
		return DataType::new_primitive(PRIM_KIND::VOID);
	}
	elif(kind == TOKEN_KIND::ANY_TYPE) {
		return DataType::new_primitive(PRIM_KIND::ANY);
	}
}

impl Parser {
	proc new(vector<Token> tokens) -> Parser = return Parser(tokens, 0, false);

	proc peek_has_value(Parser self, int offset) -> int {
		if (self.m_index + offset > self.m_tokens.size() - 1) { return false; }
		return true;
	}
	proc peek(Parser self, int offset) -> Token = return self.m_tokens.at(self.m_index + offset);
	proc peek_has_value(Parser self) -> int = return self.peek_has_value(0);
	proc peek(Parser self) -> Token = return self.peek(0);

	proc consume(Parser self) -> Token {
		let t = self.peek();
		self.m_index += 1;
		return t;
	}

	proc DiagnosticMessage(Parser self, Token tok, char* header, string msg, int col_inc) {
		printf("%s:%d:%d: %s: %s\n", tok.file.m_data, tok.line, tok.col, header, msg.m_data);
	}

	proc ParsingError(Parser self, string msg, int pos)
	{
	    if (self.peek_has_value(pos)) {
	        self.DiagnosticMessage(self.peek(pos), "error", msg, 0);
	    } elif(self.peek_has_value()) {
	        self.DiagnosticMessage(self.peek(), "error", msg, 0);
	    } else {
	        let fake = Token(TOKEN_KIND::ID, 0, 0, std::string("<eof>"), "");
	        self.DiagnosticMessage(fake, "error", msg, 0);
	    }
	    exit(EXIT_FAILURE);
	}

	proc error_expected(Parser self, string msg) {
		let boffs = 0;
		if (self.m_index > 0) {
			boffs = neg(1);
		}
		if(self.peek_has_value()) {
			self.ParsingError(std::string("excepted ") + msg + std::string(" but got ") + tok_to_string(self.peek().kind), boffs);
		} else {
			self.ParsingError(std::string("excepted ") + msg + std::string(" but got nothing"), boffs);
		}
		exit(EXIT_FAILURE);
	}

	proc try_consume_err(Parser self, int tok_kind) -> Token {
		if(self.peek_has_value() && self.peek().kind == tok_kind) {
			return self.consume();
		}
		self.error_expected(tok_to_string(tok_kind));
	}

	proc try_consume(Parser self, int tok_kind) -> Optional<Token> {
		if(self.peek_has_value() && self.peek().kind == tok_kind) {
			return Optional::new(self.consume());
		}
		return Optional::new<Token>();
	}

	proc parse_type(Parser self) -> DataType {
		let __base = self.consume();
		if(not(__base.is_type_token())) {
			self.error_expected(string::new("type"));
		}
		return token_to_dt(__base.kind);
	}

	proc parse_stmt(Parser self, int except_semi) -> Optional<NodeStmt>;
	proc parse_stmt(Parser self) -> Optional<NodeStmt>;
	proc parse_expr(Parser self, int min_prec) -> Optional<NodeExpr>;
	proc parse_expr(Parser self) -> Optional<NodeExpr>;

	proc parse_scope(Parser self) -> Optional<NodeScope> {
		if(not(self.try_consume(TOKEN_KIND::OCURLY).has_value())) {
			return Optional::new<NodeScope>();
		}
		let scope = NodeScope(vector::new<NodeStmt>());
		while(true) {
			let stmt = self.parse_stmt();
			if(self.m_preprocessor_stmt) {
				self.m_preprocessor_stmt = false;
			} else {
				if(not(stmt.has_value())) {
					break;
				}
				scope.stmts.push(stmt.value());
			}
		}
		self.try_consume_err(TOKEN_KIND::CCURLY);
		return Optional::new(scope);
	}

	proc parse_term(Parser self) -> Optional<NodeTerm> {
		if(self.peek_has_value() && self.peek().kind == TOKEN_KIND::INT_LIT) {
			let int_lit = self.consume();
			let term_int_lit = NodeTermIntLit(int_lit, std::stou(int_lit.value));
			let as_term = NodeTerm(NODE_TERM_KIND::INT_LIT, cast(ptr, term_int_lit));
			return Optional::new(as_term);
		}
		if (self.peek_has_value() && self.peek().kind == TOKEN_KIND::ID) {
		    let id_def = self.consume();
		    
		    if (self.peek_has_value() && self.peek().kind == TOKEN_KIND::OPAREN) {
		        self.consume();
		        let args = vector::new<NodeExpr>();
		        if (self.peek_has_value() && self.peek().kind != TOKEN_KIND::CPAREN) {
		            while (true) {
		                let arg_expr = self.parse_expr();
		                if (not(arg_expr.has_value())) { self.error_expected(string::new("expression")); }
		                args.push(arg_expr.value());
		                
		                if (self.peek().kind == TOKEN_KIND::COMMA) {
		                    self.consume();
		                } else {
		                    break;
		                }
		            }
		        }
		        self.try_consume_err(TOKEN_KIND::CPAREN);
		        
		        let call = NodeTermCall(string::new(id_def.value), args, id_def, null());
		        let as_term = NodeTerm(NODE_TERM_KIND::CALL, cast(ptr, call));
		        return Optional::new(as_term);
		    }
		    
		    let term_ident = NodeTermIdent(id_def, string::new(id_def.value), null());
		    let as_term = NodeTerm(NODE_TERM_KIND::IDENT, cast(ptr, term_ident));
		    return Optional::new(as_term);
		}
		return Optional::new<NodeTerm>();
	}

	proc parse_expr(Parser self, int min_prec) -> Optional<NodeExpr> {
		let term_lhs = self.parse_term();

		if(not(term_lhs.has_value())) {
			return Optional::new<NodeExpr>();
		}

		let expr_lhs = NodeExpr(NODE_EXPR_KIND::TERM, cast(ptr, term_lhs.value()), null());

		while(true) {
			if(not(self.peek_has_value())) {
				break;
			}
			let curr_tok = self.peek();
			let prec = get_bin_prec(curr_tok.kind);
			if(not(prec.has_value()) || prec.value() < min_prec) {
				break;
			}
			let ctok = self.consume();
			let next_min_prec = prec.value() + 1;

			let expr_rhs = self.parse_expr(next_min_prec);
			if(not(expr_rhs.has_value())) {
				self.error_expected(string::new("expression"));
			}

			let expr = NodeBinExpr(0, null(), Token::make_fake());
			let expr_lhs2 = NodeExpr(0, null(), null());

			expr_lhs2.var = expr_lhs.var;
			expr_lhs2.kind = expr_lhs.kind;

			if(ctok.kind == TOKEN_KIND::PLUS) {
				let add = NodeBinExprAdd(NodeExpr(expr_lhs2.kind, expr_lhs2.var, null()), NodeExpr(expr_rhs.value().kind, expr_rhs.value().var, null()));
				expr.def = ctok;
				expr.kind = NODE_BIN_EXPR_KIND::ADD;
				expr.var = cast(ptr, add);
			} elif(ctok.kind == TOKEN_KIND::MINUS) {
				let sub = NodeBinExprSub(NodeExpr(expr_lhs2.kind, expr_lhs2.var, null()), NodeExpr(expr_rhs.value().kind, expr_rhs.value().var, null()));
				expr.def = ctok;
				expr.kind = NODE_BIN_EXPR_KIND::SUB;
				expr.var = cast(ptr, sub);
			} elif(ctok.kind == TOKEN_KIND::SLASH) {
				let div = NodeBinExprDiv(NodeExpr(expr_lhs2.kind, expr_lhs2.var, null()), NodeExpr(expr_rhs.value().kind, expr_rhs.value().var, null()));
				expr.def = ctok;
				expr.kind = NODE_BIN_EXPR_KIND::DIV;
				expr.var = cast(ptr, div);
			} elif(ctok.kind == TOKEN_KIND::STAR) {
				let mul = NodeBinExprMul(NodeExpr(expr_lhs2.kind, expr_lhs2.var, null()), NodeExpr(expr_rhs.value().kind, expr_rhs.value().var, null()));
				expr.def = ctok;
				expr.kind = NODE_BIN_EXPR_KIND::MUL;
				expr.var = cast(ptr, mul);
			} else {
				assert(false, "unreachable");
			}
			expr_lhs.kind = NODE_EXPR_KIND::BIN_EXPR;
			expr_lhs.var = cast(ptr, expr);
		}
		return Optional::new(expr_lhs);
	}

	proc parse_expr(Parser self) -> Optional<NodeExpr> {
		return self.parse_expr(0);
	}

	proc parse_stmt(Parser self, int except_semi) -> Optional<NodeStmt> {
		if(not(self.peek_has_value())) {
			return Optional::new<NodeStmt>();
		}
		if(self.peek_has_value() && self.peek().kind == TOKEN_KIND::PROC) {
			let stmt_proc = NodeStmtProc(string::new(""), Token::make_fake(), NodeScope(vector::new<NodeStmt>()), DataType::new_primitive(PRIM_KIND::VOID), vector::new<pair<string, DataType>>(), 0);
			stmt_proc.def = self.consume();
			let identif = self.try_consume_err(TOKEN_KIND::ID);
			stmt_proc.name = identif.value;
			let pparams = vector::new<pair<string, DataType>>();
			self.try_consume_err(TOKEN_KIND::OPAREN);
			for(let _ = 0;self.peek_has_value() && self.peek().kind != TOKEN_KIND::CPAREN;_ += 1) {
				let argtype = self.parse_type();
				let argid = self.try_consume_err(TOKEN_KIND::ID);
				pparams.push(std::make_pair(string::new(argid.value), argtype));
				if(self.peek_has_value() && self.peek().kind != TOKEN_KIND::CPAREN) {
					self.try_consume_err(TOKEN_KIND::COMMA);
				}
			}
			stmt_proc.params = pparams;
			self.try_consume_err(TOKEN_KIND::CPAREN);
			if(self.try_consume(TOKEN_KIND::ARROW).has_value()) {
				stmt_proc.rettype = self.parse_type();
			}
			let scope = self.parse_scope();
			if(scope.has_value()) {
				stmt_proc.scope = scope.value();
			} else {
				self.ParsingError(string::new("after proc name except `{` and `}` after body"), neg(1));
			}
			let stmt = NodeStmt(NODE_STMT_KIND::PROC, cast(ptr, stmt_proc));
			return Optional::new(stmt);
		}
		if(self.peek_has_value() && self.peek().kind == TOKEN_KIND::LET) {
			let stmt_let = NodeStmtLet(string::new(""), Token::make_fake(), Optional::new<DataType>(), Optional::new<NodeExpr>(), 0);
			self.consume();
			stmt_let.def = self.try_consume_err(TOKEN_KIND::ID);
			stmt_let.name = string::new(stmt_let.def.value);
			if(self.try_consume(TOKEN_KIND::DOUBLE_DOT).has_value()) {
				stmt_let.type = Optional::new(self.parse_type());
			}
			if(self.peek_has_value() && self.peek().kind != TOKEN_KIND::SEMI) {
				self.try_consume_err(TOKEN_KIND::EQ);
				let expr = self.parse_expr();
				if(expr.has_value()) {
					stmt_let.expr = expr;
				} else {
					self.error_expected(string::new("expression"));
				}
			}
			if(except_semi) {
				self.try_consume_err(TOKEN_KIND::SEMI);
			}
			let stmt = NodeStmt(NODE_STMT_KIND::LET, cast(ptr, stmt_let));
			return Optional::new(stmt);
		}
		if(self.peek_has_value() && self.peek().kind == TOKEN_KIND::RETURN) {
			let def = self.consume();
			let stmt_return = NodeStmtReturn(def, self.parse_expr(), string::new(""));
			if(except_semi) {
				self.try_consume_err(TOKEN_KIND::SEMI);
			}
			let stmt = NodeStmt(NODE_STMT_KIND::RETURN, cast(ptr, stmt_return));
			return Optional::new(stmt);
		}
		let nexpr = self.parse_expr();
		if(nexpr.has_value()) {
			let cexpr = nexpr.value();
			let stmt_expr = NodeStmtExpr(cexpr);
			let stmt = NodeStmt(NODE_STMT_KIND::EXPR, cast(ptr, stmt_expr));
			if(except_semi) {
				self.try_consume_err(TOKEN_KIND::SEMI);
			}
			return Optional::new(stmt);
		}
		return Optional::new<NodeStmt>();
	}

	proc parse_stmt(Parser self) -> Optional<NodeStmt> {
		return self.parse_stmt(true);
	}

	proc parse_prog(Parser self) -> NodeProg {
		let prog = NodeProg(vector::new<NodeStmt>());
		while (self.peek_has_value()) {
			let stmt = self.parse_stmt();
			if(stmt.has_value()) {
				prog.stmts.push(stmt.value());
			} else {
				if(self.m_preprocessor_stmt) {
					self.m_preprocessor_stmt = false;
				} else {
					self.error_expected(std::string("statement"));
				}
			}
		}
		return prog;
	}
}