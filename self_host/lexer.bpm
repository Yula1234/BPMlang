include "std"
include "self_host/arena"
include "string"
include "string_view"

struct lexer {
	src:StringView,
	index:int,
	col:int
}

proc new_lexer src:ptr -> lexer {
	let src_sv = sv_from(src);
	return lexer(src_sv, 0, 1);
}

proc lexer_delete lxr:lexer -> void {
	delete lxr.src;
	delete lxr;
}

proc lexer_consume lxr:lexer -> int {
	let chr = sv_at(lxr.src, lxr.index);
	lxr.index = lxr.index + 1;
	lxr.col = lxr.col + 1;
	return chr;
}

const NULL_PEEK 4294967295;

proc lexer_peek lxr:lexer -> int {
	if(lxr.index > lxr.src.count) {
		return NULL_PEEK;
	}
	return sv_at(lxr.src, lxr.index);
}

proc lexer_peek_at lxr:lexer offs:int -> int {
	if((lxr.index + offs) > lxr.src.count) {
		return NULL_PEEK;
	}
	return sv_at(lxr.src, lxr.index + offs);
}

struct TmpStr {
	used:int,
	capacity:int,
	data:ptr
}

proc new_tmp_str arena:ArenaAllocator size:int -> TmpStr {
	return TmpStr(0, size, arena_take(arena, size));
}

proc tmp_str_push str:TmpStr chr:int -> void {
	store8(str.data + str.used, chr);
	str.used = str.used + 1;
	store8(str.data + str.used, 0);
}

proc isspace chr:int -> int {
	if(chr == ' ') {
		return true;
	}
	return false;
}

proc isdigit chr:int -> int {
	if(chr > ('0' - 1)) {
		if(chr < ('9' + 1)) {
			return true;
		}
		return false;
	}
	else {
		return false;
	}
}

proc is_identif chr:int -> int {
	if(chr == '_') {
		return true;
	}
	if(chr < 'A') {
		return false;
	}
	if(chr > 'z') {
		return false;
	}
	if(chr > 'Z') {
		if(chr < 'a') {
			return false;
		}
	}
	return true;
}

const TokenIdent 0;

struct Token {
	type:int,
	line:int,
	col:int,
	value:ptr
}

proc push_token tokens:ptr index:ptr tok:Token -> void {
	store32(tokens + (rd32(index) * 4), cast(ptr, tok));
	store32(index, rd32(index) + 1);
}

proc ptr_to_tok p:ptr -> Token {
	asm "push dword [ebp-4]";
}

proc lexer_lex
	lxr:lexer
	str_arena:ArenaAllocator
	tokens:ptr
-> void 
{
	let tokens_count = 0;
	let line_count = 1;
	let tmp_str = new_tmp_str(str_arena, 56);
	while(lexer_peek(lxr) != NULL_PEEK) {
		if(is_identif(lexer_peek(lxr))) {
			while(is_identif(lexer_peek(lxr))) {
				tmp_str_push(tmp_str, lexer_consume(lxr));
			}
			puts(tmp_str.data);
			tmp_str = new_tmp_str(str_arena, 56);
		}
		elif(lexer_peek(lxr) == '\n') {
			line_count = line_count + 1;
			lexer_consume(lxr);
		}
		elif(isspace(lexer_peek(lxr))) {
			while(isspace(lexer_peek(lxr))) {
				lexer_consume(lxr);
			}
		}
		else {
			lexer_consume(lxr);
		}
	}
}