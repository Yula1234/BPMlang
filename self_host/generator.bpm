include "std"
include "string"
include "string_view"
include "fsys"
include "self_host/arena"
include "self_host/lexer"
include "self_host/parser"

struct Generator {
	asm_file:FILE
}

proc gen_generate_expr expr:NodeExpr gen:Generator -> void {
	if(expr.kind == NodeKindInt) {
		format_fprint(gen.asm_file.desc, "    push dword %s\n", expr.data);
	}
	elif(expr.kind == NodeKindPlus) {
		let bin_add = cast(NodeExprAdd, expr.data);
		gen_generate_expr(cast(NodeExpr, bin_add.left), gen);
		gen_generate_expr(cast(NodeExpr, bin_add.right), gen);
		fputs(gen.asm_file.desc, "    pop ebx\n");
		fputs(gen.asm_file.desc, "    pop eax\n");
		fputs(gen.asm_file.desc, "    add eax, ebx\n");
		fputs(gen.asm_file.desc, "    push eax\n");
	}
	elif(expr.kind == NodeKindMinus) {
		let bin_sub = cast(NodeExprSub, expr.data);
		gen_generate_expr(cast(NodeExpr, bin_sub.left), gen);
		gen_generate_expr(cast(NodeExpr, bin_sub.right), gen);
		fputs(gen.asm_file.desc, "    pop ebx\n");
		fputs(gen.asm_file.desc, "    pop eax\n");
		fputs(gen.asm_file.desc, "    sub eax, ebx\n");
		fputs(gen.asm_file.desc, "    push eax\n");
	}
	elif(expr.kind == NodeKindMul) {
		let mul_expr = cast(NodeExprMul, expr.data);
		gen_generate_expr(cast(NodeExpr, mul_expr.left), gen);
		gen_generate_expr(cast(NodeExpr, mul_expr.right), gen);
		fputs(gen.asm_file.desc, "    pop ebx\n");
		fputs(gen.asm_file.desc, "    pop eax\n");
		fputs(gen.asm_file.desc, "    imul eax, ebx\n");
		fputs(gen.asm_file.desc, "    push eax\n");
	}
	elif(expr.kind == NodeKindDiv) {
		let div_expr = cast(NodeExprMul, expr.data);
		gen_generate_expr(cast(NodeExpr, div_expr.left), gen);
		gen_generate_expr(cast(NodeExpr, div_expr.right), gen);
		fputs(gen.asm_file.desc, "    pop ebx\n");
		fputs(gen.asm_file.desc, "    pop eax\n");
		fputs(gen.asm_file.desc, "    xor edx, edx\n");
		fputs(gen.asm_file.desc, "    div ebx\n");
		fputs(gen.asm_file.desc, "    push eax\n");
		fputs(gen.asm_file.desc, "    mov edx, ecx\n");
	}
	else {
		format_print("ERROR: unkown expr.kind at `gen_generate_expr` - ");
		putu(expr.kind);
		exit(1);
	}
}

proc gen_generate_exit stmt:NodeStmtExit gen:Generator -> void {
	let expr = cast(NodeExpr, stmt.expr);
	gen_generate_expr(expr, gen);
	fputs(gen.asm_file.desc, "    call ExitProcess@4\n");
	fputs(gen.asm_file.desc, "    add esp, 4\n");
}

proc gen_generate_print stmt:NodeStmtPrint gen:Generator -> void {
	let expr = cast(NodeExpr, stmt.expr);
	gen_generate_expr(expr, gen);
	fputs(gen.asm_file.desc, "    push numfmt\n");
	fputs(gen.asm_file.desc, "    call printf\n");
	fputs(gen.asm_file.desc, "    add esp, 8\n");
}

proc gen_stmt _stmt:ptr gen:Generator -> void {
	let stmt = cast(NodeStmt, _stmt);
	if(stmt.kind == StmtKindExit) {
		let stmt_exit = cast(NodeStmtExit, stmt.data);
		gen_generate_exit(stmt_exit, gen);
	}
	elif(stmt.kind == StmtKindPrint) {
		let stmt_print = cast(NodeStmtPrint, stmt.data);
		gen_generate_print(stmt_print, gen);
	}
}

proc gen_generate_header gen:Generator -> void {
	fputs(gen.asm_file.desc, "section .text\n\n");
	fputs(gen.asm_file.desc, "global main\n\n");
	fputs(gen.asm_file.desc, "extern printf\n");
	fputs(gen.asm_file.desc, "extern ExitProcess@4\n\n");
	fputs(gen.asm_file.desc, "main:\n");
	fputs(gen.asm_file.desc, "    push ebp\n");
	fputs(gen.asm_file.desc, "    mov ebp, esp\n");
}

proc gen_generate_footer gen:Generator -> void {
	fputs(gen.asm_file.desc, "    xor eax, eax\n");
	fputs(gen.asm_file.desc, "    pop ebp\n");
	fputs(gen.asm_file.desc, "    ret\n");
}

proc gen_generate_data gen:Generator -> void {
	fputs(gen.asm_file.desc, "\nsection .data\n");
	fputs(gen.asm_file.desc, "    numfmt: db \"%d\", 0xa, 0x0\n");
}

proc gen_generate ast:ptr gen:Generator -> void {
	let ast_level = 0;
	gen_generate_header(gen);
	while(rd32(ast +  (ast_level * 4)) != 0) {
		gen_stmt(cast(ptr, rd32(ast +  (ast_level * 4))), gen);
		ast_level = ast_level + 1;
	}
	gen_generate_footer(gen);
	gen_generate_data(gen);
}